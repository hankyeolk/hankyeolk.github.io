<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://hankyeolk.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hankyeolk.github.io/" rel="alternate" type="text/html" /><updated>2021-08-12T09:05:19+09:00</updated><id>https://hankyeolk.github.io/feed.xml</id><title type="html">HK Blog</title><subtitle>웹 개발자 강한결의 개발 블로그입니다.</subtitle><author><name>hankyeolk</name></author><entry><title type="html">Create-React-App 없이 리액트 프로젝트 보일러 플레이스 세팅하기</title><link href="https://hankyeolk.github.io/2021/08/08/withoutCRA.html" rel="alternate" type="text/html" title="Create-React-App 없이 리액트 프로젝트 보일러 플레이스 세팅하기" /><published>2021-08-08T00:00:00+09:00</published><updated>2021-08-08T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/08/08/withoutCRA</id><content type="html" xml:base="https://hankyeolk.github.io/2021/08/08/withoutCRA.html">&lt;h1 id=&quot;create-react-app-없이-리액트-프로젝트-환경-구축하기&quot;&gt;Create-React-App 없이 리액트 프로젝트 환경 구축하기&lt;/h1&gt;

&lt;h3 id=&quot;직접-환경을-구축해보는-것에-대해서&quot;&gt;직접 환경을 구축해보는 것에 대해서&lt;/h3&gt;

&lt;p&gt;CRA는 분명히 빠른 리액트 프로젝트를 시작하게 만들어주는 좋은 도구임에는 틀림없다. CRA를 통해서 프로젝트 자체를 빌드 할 수 있다. CRA가 나쁘다는 이야기를 하려고 이 글을 적는 것이 아님을 시작에 강조한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그럼에도 내가 이 기록을 남기는 이유는 너무 맹목적인 CRA를 남발하지 않기 위함이다. 웹팩으로 프로젝트를 구축해보면서 어떤 플러그인, 로더를 적소에 적용해야 하는지 배우기 위함이다. 바벨을 통해서 어떻게 언어의 문법간 호환성을 지켜야 하는지를 공부하기 위함이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그래도 나는 여전히 CRA가 너무 편하고 좋다. 필요하다면 CRA를 적극적으로 쓰는 것도 좋은 것 같다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;시작은-필요한-모듈-설치로부터&quot;&gt;시작은 필요한 모듈 설치로부터&lt;/h3&gt;

&lt;p&gt;나는 yarn으로 노드 모듈을 설치하는 것을 좋아한다. 조금 더 빠르다는 느낌도 있고, 터미널에서 모듈을 받았을때 나오는 문구도 조금 더 세련된 것 같아서 그렇다. 그래서 기록의 대부분은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add&lt;/code&gt;로 구성될 것 같다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;우선, 프로젝트를 시작할 폴더를 하나 만들고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn init -y&lt;/code&gt;로 노드 프로젝트임을 드러낸다. 그리고 리액트와 관련된 모듈을 설치한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add react react-dom&lt;/code&gt; react-dom은 react와 dom을 직접적으로 연결해주는 모듈이다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Babel &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그 다음, 자바스크립트의 서로다른 문법간의 오류를 하나로 통합해줄 바벨의 모듈들을 설치한다. JSX와 ES6 이상의 문법을 다른 브라우저가 이해할 수 있도록 ES5 문법으로 변환해준다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add @babel/core @babel/preset-react @babel/preset-env&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;바벨의 모듈은 앞에 ‘@’ 마크가 붙는 특징이 있다. 바벨에 대한 자세한 설명은 이전 TIL에 개발환경 구축의 내용을 정리한 것이 있다. 그 부분을 함께 참고하자. &lt;a href=&quot;https://github.com/hankyeolk/TIL/blob/main/Dev_Env/babel.md&quot;&gt;개발환경 이해하기 - Babel&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@babel/preset-react : 리액트의 JSX 문법을 자바스크립트 코드로 변환해준다.&lt;/li&gt;
  &lt;li&gt;@babel/preset-env : ES6 이상의 자바스크립트 문법을 다른 브라우져에서도 호환 가능하도록 ES5로 변환해주는 프리셋이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Webpack and Loader &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로젝트 환경 구축의 핵심인 웹팩과 관련 모듈을 설치한다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add -D webpack webpack-cli webpack-dev-server babel-loader css-loader style-loader&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack-dev-server&lt;/code&gt; : 이름에서도 알 수 있듯이 개발 모드에 필요한 서버를 구동해준다. 컴퓨터의 메모리를 빌려 웹팩을 구동하고 임0시 서버를 띄우는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;css-loader, style-loader&lt;/code&gt; : css 문법을 자바스크립트로 변환해주는 역할을 한다. / css-loader가 변환한 파일을 index.html의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그에 넣는 역할을 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 다음, 번들링 파일에 적용할 플러그인을 설치한다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add -D html-webpack-plugin clean-webpack-plugin&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html-webpack-plugin&lt;/code&gt;: html파일에 번들링된 리액트 코드를 삽입해준다. 그리고 dist 폴더에 번들링된 파일을 옮겨주는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clean-webpack-plugin&lt;/code&gt; : 번들링이 완료될 때마다 이전의 번들링 결과를 제거해주는 역할을 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;이제-바벨-웹팩-설정-파일을-만들면서-프로젝트-환경을-완성해보자&quot;&gt;이제 바벨, 웹팩 설정 파일을 만들면서 프로젝트 환경을 완성해보자.&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;babel.config.js &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;바벨 설정 파일에는 프리셋을 잘 적용해주는 것이 중요하다. 프리셋은 바벨의 역할들을 모아둔 도구 상자라고 생각하면 편하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt; 이름으로 파일 이름을 지을 수도 있다. 이렇게 사용할 프리셋을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;presets&lt;/code&gt; 항목에 배열로 넣어주면된다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// babel.config.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;presets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;@babel/preset-env&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;@babel/preset-react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;webpack.config.js &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 중요한 설정은 웹팩 설정이다. 실질적으로 웹팩으로 어떻게 번들링을 하는지에 따라서 프로젝트의 결과가 완전히 달라질 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack.config.js&lt;/code&gt;파일을 구축하면서 꼼꼼하게 알아보자.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// webpack.config.js&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HtmlWebpackPlugin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;html-webpack-plugin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CleanWebpackPlugin&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;clean-webpack-plugin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dotenv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;dotenv&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설정에서 사용하는 개발 모드/프로덕션 모드를 구분하고 개발 서버의 포트 변호를 환경변수로 관리하기 위해서 dotenv를 설치해서 사용했다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./src/index.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__dirname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/dist&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;bundle.[hash].js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;publicPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// path.resove 형태로 사용할 수도 있다.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 그러면 node의 기본 모듈 'path'를 불러와야 한다.&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;extensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;.jsx&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;번들링이 시작될 곳은 리액트 프로젝트에서 보통 리액트 돔에 랜더링을 거는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index.js&lt;/code&gt;로 정했다. 엔트리 포인트는 개발자가 알아서 정해주면 된다. 번들링 결과는 보통 dist 폴더에 해쉬가 된채로 저장된다. 번들링을 할 파일은 ‘.js, .jsx’의 확장자를 가진 파일이다. 나는 보통 자바스크립트로 리액트 프로젝트를 할 경우 컴포넌트 파일명을 ‘.jsx’ 확장자로 짓는다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\.(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;js|jsx&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;$/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;exclude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/node_modules/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;babel-loader&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;css$/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;style-loader&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;css-loader&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로더는 rules 항목에서 지정해줄 수 있다. 중점적으로 신경써야 하는 것은 로더의 순서다. 웹팩은 등록한 로더의 배열에서 뒤의 요소부터 번들링에 반영한다. css를 자바스크립트로 변환한 다음 style 태그에 넣어주어야 하기 때문에 위의 순서를 가진다. 또한 node_modules 폴더의 모든 모듈들을 다 번들링 할 필요 없기 때문에 이걸 제외해주는 것도 중요하다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CleanWebpackPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HtmlWebpackPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;public/index.html&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;DefinePlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;devServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;historyApiFallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;hot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;플러그인은 각 생성자 함수로 인스턴스를 만들어주는 방식으로 적용한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefinePlugin&lt;/code&gt;의 경우 웹팩의 기본 플러그인이라서 webpack으로 부터 가지고 왔다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.env&lt;/code&gt; 파일에 등록한 개발 모드와 포트 넘버를 등록해서 사용할 수 있게 해준다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devServer&lt;/code&gt;는 개발 서버를 열어주는 용도다. ‘hot’ 키워드를 true 값으로 설정해서 변화가 발생하면 바로 번들링이 발동되고 서버에 반영될 수 있도록 설정해주면 우리가 react 프로젝트에서 늘 봤던 ‘yarn start’를 만들어준다. 물론 스크립트에 등록을 해야한다. &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;packagejson-파일에-스크립트-등록하고-리액트-개발-시작하기&quot;&gt;package.json 파일에 스크립트 등록하고 리액트 개발 시작하기&lt;/h3&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;webpack serve --progress --mode development&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;build&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;webpack&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“start” 명령어에 ‘webpack-dev-server’를 등록해서 리액트 스크립트가 동작할 수 있도록 설정한다. ‘hot’ 키워드가 등록되어 있기때문에 프로젝트는 리액트의 사소한 변화를 반영할 수 있다. “build” 명령어를 동작하면 dist 폴더에 번들링된 파일들이 생성될 것이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 우리에게 남은 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public/index.html&lt;/code&gt;을 생성하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src/index.js&lt;/code&gt;에 가벼운 리액트 코드를 작성하는 것이다. 물론 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn start&lt;/code&gt; 명령어로 웹팩을 돌리고 3000번 포트(.env에 설정해준)에서 결과를 확인하는 것은 덤이다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- public/index.html --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width=divice-width, initial-scale=1.0&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;http-equiv=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ie=edge&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;react-twittler&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// index.js&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ReactDom&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;react-dom&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hankyeol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;ReactDom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/wSzh8iSdYUQ&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;blockquote&gt;
  &lt;p&gt;부끄럽지만.. 회사에서 해당 내용으로 기술 발표 영상을 찍었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="js" /><category term="series" /><category term="book" /><summary type="html">Create-React-App 없이 리액트 프로젝트 환경 구축하기</summary></entry><entry><title type="html">[시리즈 - 코어 자바스크립트] 자바스크립트 프로토타입</title><link href="https://hankyeolk.github.io/2021/06/30/coreJavascript3.html" rel="alternate" type="text/html" title="[시리즈 - 코어 자바스크립트] 자바스크립트 프로토타입" /><published>2021-06-30T00:00:00+09:00</published><updated>2021-06-30T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/06/30/coreJavascript3</id><content type="html" xml:base="https://hankyeolk.github.io/2021/06/30/coreJavascript3.html">&lt;blockquote&gt;
  &lt;p&gt;이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;자바스크립트-프로토타입&quot;&gt;자바스크립트 프로토타입&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바스크립트가 프로토타입 기반의 언어라는 점은 많이 들어서 알고 있을 것이다. 클래스 기반의 언어에 있는 상속과는 다르게 특정한 객체 하나를 원형(prototype)으로 삼고 이를 복제하는 방식으로 상속의 훙내낸다. 프로토타입의 개념을 한 번 이해하는 것이 어렵지만 이번에 해내보자.&lt;/p&gt;

&lt;h3 id=&quot;기본&quot;&gt;기본&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/core-javascript/prototype.png&quot; style=&quot;width: 80%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 이미지의 흐름을 정리하면 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;어떤 생성자 함수를 new 키워드와 함께 호출하면 생성자에서 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성된다.&lt;/li&gt;
  &lt;li&gt;인스턴스가 생성될때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;라고 하는 프로퍼티가 자동으로 부여된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티는 Constructor에 있는 prototype 이라고 하는 프로퍼티를 참조한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prototype&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;는 모두 객체다. prototype 객체에는 인스턴스가 사용할 메서드를 저장한다. 이를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;를 통해 인스턴스가 이 메서드들에 접근할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Dobby&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//undefined&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dobby.__proto__.getName()&lt;/code&gt;을 찍어보면 undefined가 나오는 것을 알 수 있다. 함수를 메서드로 호출하면 ‘.’ 앞의 객체가 바로 this가 된다. 그래서 getName 메서드가 묶인 this는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dobby.__proto__&lt;/code&gt; 객체가 된다. 이 객체 내부에는 ‘name’이라는 프로퍼티가 없기 때문에 정의되지 않은 식별자를 찾을때 뱉는 undefined가 나온 것이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Dobby&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 'Dobby'&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 'Dobby'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dobby.getName()&lt;/code&gt; 처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;를 제외하면 this 걱정없이 메서드를 사용할 수 있다. 그 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;가 생략 가능한 프로퍼티이기 때문이다. 자바스크립트의 단순한 문법적인 측면이기 때문에 생략 가능하다는 정도로만 이해하고 넘어가자.&lt;/p&gt;

&lt;p&gt;정리하면, ‘new Constructor() 형태로 인스턴스를 생성하면 생략 가능한 프로퍼티 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;가 생성되고 이것은 Constructor의 prototype 객체를 참조한다.’&lt;/p&gt;

&lt;p&gt;Array라고 하는 생성자를 직접 콘솔에 찍어보면 prototype과 기본 내장 메서드를 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;prototype-객체-내부의-constructor-프로퍼티&quot;&gt;prototype 객체 내부의 constructor 프로퍼티&lt;/h3&gt;

&lt;p&gt;생성자 함수의 prototype 객체에는 constructor라고 하는 자기 자신을 참조하는 프로퍼티가 있다. 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 객체에도 존재한다. 이것은 인스턴스와의 관계를 나타내기 위해 필요한 정보인데, 인스턴스의 원형이 무엇인지를 알 수 있는 수단 역할을 한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [3, 4]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로토타입-체인&quot;&gt;프로토타입 체인&lt;/h3&gt;

&lt;h4 id=&quot;메서드-오버라이드&quot;&gt;메서드 오버라이드&lt;/h4&gt;

&lt;p&gt;prototype 객체를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;를 생략할 수 있기 때문에, 인스턴스는 prototype에 정의된 프로퍼티나 메서드를 자신의 것처럼 사용할 수 있는 것처럼 보인다. 아래의 예시를 한 번 보자.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;이지은&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;IU는 &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;이다.&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 'IU는 이지은이다.'&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// '이지은'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IU 인스턴스에 있는 메서드가 호출된다. Person prototype 객체에 등록된 getName 메서드와 동일한 함 수 명이기 때문에 원본이 있는 그 상태에서 다른 대상을 얹은 것이다.&lt;/p&gt;

&lt;p&gt;오버라이딩 되지 않고, prototype에 등록된 메서드가 동자가헤 하려면, IU 인스턴스에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;에다가 IU 인스턴스를 바라볼 수 있게 등록하면 된다. call, apply 메서드로 바인딩을 해주면 된다. 원본 메서드를 사용하기 위해서 우회를 해야한다는 점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로토타입-체인-1&quot;&gt;프로토타입 체인&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.dir([1, 2])&lt;/code&gt;를 찍어보면 우리에게 익숙한 pop, push와 같은 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티 안에 있다는 것을 볼 수 있다. constructor는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Array()&lt;/code&gt;로 배열 생성자 함수를 가르키고 있는 것으로 보인다. 그런데 &lt;strong&gt;proto&lt;/strong&gt;안에 또 다른 &lt;strong&gt;proto&lt;/strong&gt;가 있는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;그것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.dir({a: 1})&lt;/code&gt;을 찍어봤을 때의 &lt;strong&gt;proto&lt;/strong&gt;와 동일하다는 것을 알 수 있다. 이것은 모든 객체의 &lt;strong&gt;proto&lt;/strong&gt;에 Object.prototype이 연결되기 때문이다. 아래의 그림처럼 연결되어 있는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/core-javascript/prototype2.png&quot; style=&quot;width: 80%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt;는 생략이 가능한 프로퍼티이기 때문에 배열은 Object.prototype의 내부 메서드를 자신의 것처럼 사용할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;array(.__proto__)(.__proto__).hasOwnProperty();&lt;/code&gt; 이렇게 말이다.&lt;/p&gt;

&lt;p&gt;이런 것처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티 내부에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티가 연쇄적으로 이어진 형태를 프로토타입 체인이라고 한다. 이 체인을 따라가며 검색하는 과정을 프로토타입 체이닝이라고 한다.&lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="js" /><category term="series" /><category term="book" /><summary type="html">이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.</summary></entry><entry><title type="html">[시리즈 - 코어 자바스크립트] 자바스크립트 실행 컨텍스트</title><link href="https://hankyeolk.github.io/2021/06/19/coreJavascript2.html" rel="alternate" type="text/html" title="[시리즈 - 코어 자바스크립트] 자바스크립트 실행 컨텍스트" /><published>2021-06-19T00:00:00+09:00</published><updated>2021-06-19T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/06/19/coreJavascript2</id><content type="html" xml:base="https://hankyeolk.github.io/2021/06/19/coreJavascript2.html">&lt;blockquote&gt;
  &lt;p&gt;이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;자바스크립트-실행-컨텍스트&quot;&gt;자바스크립트 실행 컨텍스트&lt;/h3&gt;

&lt;p&gt;실행 컨텍스트는 실행할 코드에 제공할 환경 정보를 모아놓은 객체다. 어떤 실행 컨텍스트가 활성화되는 시점에 어떤 변수가 끌어올려지고, 외부 환경 정보를 설정하고, this 값을 설정하는 등의 동작을 수행한다.&lt;/p&gt;

&lt;p&gt;동일 환경에 있는 코드를 실행할 때 필요한 환경 정보를 모두 모아 컨텍스트로 구성하고, 이를 콜 스택에 쌓아올린다. 여기서 스택은 자료구조의 ‘그’ 스택이 맞다. 가장 위에 쌓은 컨택스트와 관련있는 코드를 실행하는 식으로 전체 코드의 환경과 순서를 정한다.&lt;/p&gt;

&lt;p&gt;하나의 동일한 환경, 하나의 실행 컨텍스트를 구성할 수 있는 방법은 다양하게 있다. 전역공간에서의 작업, eval() 함수의 활용, 가장 흔한 방법은 함수를 &lt;strong&gt;실행하는 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-컨텍스트-스택의-기본-동작&quot;&gt;실행 컨텍스트 스택의 기본 동작&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// -- (1)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -- (2)&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -- (3)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 (1)의 환경은 전역 컨텍스트다. 코드가 읽히는 순간 가장 먼저 콜 스택에 담긴다. 전역 컨텍스트는 별도의 실행 명령 없이도 브라우저에서 자동으로 실행하는 컨텍스트다. 말 그대로 파일이 브라우저에서 열리는 순간 전역이 펼쳐지는 것이다.&lt;/p&gt;

&lt;p&gt;전역적으로 코드들을 담다가, (3)에서 함수 호출을 만나면 outer 함수에 대한 환경 정보들을 컨텍스트로 생성하여 콜 스택에 담는다. outer() 함수의 실행 컨텍스트를 콜 스택에 담는 것이다. 이제 전역에서 시행하는 것을 멈추고 outer 함수 내부의 코드들을 순차적으로 실행시킨다.&lt;/p&gt;

&lt;p&gt;outer() 함수 내부에서 inner() 함수를 호출하는 (2)번 환경이 있기 때문에 콜 스택은 해당 inner 함수의 환경을 실행 컨텍스트로 담는다. 스택의 특성상 가장 뒤에 들어온 요소를 가장 먼저 처리해야하기 때문에 inner가 처리되고, outer, 다시 전역 순서로 진행한다.&lt;/p&gt;

&lt;p&gt;하나의 실행 컨텍스트가 콜 스택의 가장 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점이다. 새로운 스택으로 특정 컨텍스트가 활성화되면 해당 코드를 실행하는 것에 필요한 환경 정보를 수집한 객체가 실행 컨텍스트에 저장되는 방식이 자바스크립트의 동작 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-컨텍스트-객체-엘리먼트&quot;&gt;실행 컨텍스트 객체 엘리먼트&lt;/h3&gt;

&lt;p&gt;실행 컨텍스트 객체는 자바스크립트 엔진이 코드를 돌리는 목적으로 생성되기 때문에 우리가 코드를 통해서 직접 확인하기는 힘들다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Variable Environment (변수 환경)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;현재 컨택스트가 가지고 있는 식별자에 대한 정보, 외부 환경 정보, 선언 시점의 Lexical 환경의 스냅샷을 가지는 환경이다. 해당 컨텍스트가 최초로 실행될 때의 스냅샷을 유지한다. 이 스냅샷을 그대로 복사해서 Lexical 환경을 만든다. 실핵 컨텍스트의 템플릿을 만드는 격이라고 생각하면 편하겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lexical Environment (사전적 환경)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;처음 선언될 때에는 Variable 환경과 동일하지만 변경사항이 생기면 실시간으로 반영되는 환경이다. “현재 컨텍스트에는 어떤 어떤 식별자들이 있고, 외부 환경에 대한 정보는 특정 어떤 주소를 참조하도록 되어있다.” 이런 형식으로 사전처럼 정의된 환경이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;environmentRecord&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;environmentRecord에는 현재 컨텍스트와 관련된 코드 식별자 정보가 저장된다. 함수의 매개변수 이름, 함수 그 자체, 선언된 변수가 컨텍스트의 식별자가 된다. 코드 위에서 아래로 훑으며 순서대로 수집한다.&lt;/p&gt;

&lt;p&gt;수집된 식별자들은 호이스팅을 통해서, 자바스크립트 엔진이 실질적으로 식별자들을 실행의 가장 상단으로 끌어올리지는 않지만, 코드 해석의 최상단으로 끌어올려진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;호이스팅-hoisting--hoist--ing-규칙&quot;&gt;호이스팅 (hoisting = hoist + ing) 규칙&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;특정 실행 컨텍스트에 대해서 변수는 선언만 끌어올린다. 할당은 끌어올리지 않는다. 매개변수로 들어오는 값도 동일하다.&lt;/li&gt;
  &lt;li&gt;함수에 대한 선언은 함수 전체를 끌어올린다. 동일 변수명으로 함수를 선언하면 해당 변수명의 주소값에 함수만 담겨 끌어올려진다고 생각하자. 다만, 표현식으로 작성된 함수는 끌어올려지지 않는다. 할당의 개념이기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;함수 선언과 표현식&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;함수를 정의하는 방법은 아래의 3가지 방식을 따른다. 선언식의 경우 보통 function 키워드로 선언하는 부분만 존재하고 별도의 할당 과정이 없다. 함수 선언식의 경우에는 반드시 함수명이 정의되어야 한다.&lt;/p&gt;

&lt;p&gt;이와 반대로 함수 표현식은 정의한 함수를 별도 변수에 할당하는 과정 자체를 의미한다. 표현식으로 작성된 함수는 별도의 이름이 꼭 존재하지는 않아도 된다. 익명함수라고도 한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 선언식&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 표현식 -&amp;gt; function 키워드&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 이름이 있는 함수 표현식 -&amp;gt; 외부에서 해당 함수명으로 호출 불가&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -&amp;gt; error&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 표현식 -&amp;gt; arrow function&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;스코프&quot;&gt;스코프&lt;/h3&gt;

&lt;p&gt;스코프는 식별자, 변수가 접근 가능한 유효범위다. ES6부터 자바스크립트는 함수, 블록에 대한 스코프가 구분되었다. 식별자의 유효범위가 안에서부터 바깥으로 순서대로 검색하는 체인을 ‘스코프 체인’이라고 한다. 자바스크립트에서 스코프는 중괄호로 구분한다. 또한 함수의 내부에 식별자가 있는지 외부에 있는지도 스코프를 따지는 것에 큰 영향을 준다.&lt;/p&gt;

&lt;p&gt;스코프의 규칙을 정리하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내부에 있는 스코프에서 외부의 스코프로의 접근은 가능하다. 즉, 내부 스코프에서 외부에 정의된 변수를 조회할 수 있고, 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;외부 스코프에서는 내부에 정의된 식별자를 조회할 수 없다. 이것을 통해서 우리는 변수의 은닉화를 할 수 있다.&lt;/li&gt;
  &lt;li&gt;스코프는 중첩이 가능하다. 중첩된 가장 외부의 스코프를 전역(global), 그것이 아닌 스코프는 모두 지역(local) 스코프다.&lt;/li&gt;
  &lt;li&gt;지역 스코프 내에서 선언된 식별자, 변수가 Lexical 환경에서 조회되기 때문에 우선순위를 가진다. Lexical한 환경에서 선언된 식별자가 없다면 그 다음 스코프를 뒤지고 또 다음 스코프를 뒤지는 형식으로 가는 것이다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hankyeolk</name></author><category term="js" /><category term="series" /><category term="book" /><summary type="html">이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.</summary></entry><entry><title type="html">[시리즈 - 코어 자바스크립트] 자바스크립트 데이터 타입</title><link href="https://hankyeolk.github.io/2021/06/12/coreJavascript1.html" rel="alternate" type="text/html" title="[시리즈 - 코어 자바스크립트] 자바스크립트 데이터 타입" /><published>2021-06-12T00:00:00+09:00</published><updated>2021-06-12T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/06/12/coreJavascript1</id><content type="html" xml:base="https://hankyeolk.github.io/2021/06/12/coreJavascript1.html">&lt;blockquote&gt;
  &lt;p&gt;이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;자바스크립트의-데이터-타입&quot;&gt;자바스크립트의 데이터 타입&lt;/h3&gt;

&lt;p&gt;자바스크립트의 데이터 타입은 크게 2가지가 있다. 기본형(primitive)과 참조형(reference) 타입이다. 타입을 구분하는 기준에 대해서 명확하게 아는 것이 중요하다. 두 타입 모두 무언가를 &lt;strong&gt;‘복제’&lt;/strong&gt;하긴 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;기본형 타입은 값이 담긴 주소의 값을 바로 복제한다. 그리고 기본형은 불변성(immutability)을 띈다. 기본형에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Number, String, Boolean, null, undefined, Symbol&lt;/code&gt;이 있다. Symbol 타입은 ES6 이후에 등장했다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참조형 타입은 값이 담긴 주소의 값들로 이루어진 묶음의 주소 값을 복제한다. 참조형에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt;가 있고 객체 아래에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array, Function, Date, RegExp, Map, Set&lt;/code&gt;이 속한다. 객체 하위 분류에 해당한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;식별자와-변수&quot;&gt;식별자와 변수&lt;/h3&gt;

&lt;p&gt;모든 데이터는 바이트(8비트) 단위의 식별자를 통해서 서로 구분하고 연결할 수 있다. &lt;strong&gt;식별자는 우리가 잘 아는 ‘변수명’이다. 더 정확하게는 메모리 주솟값&lt;/strong&gt;이다. 변수는 말 그대로 변할 수 있는 값이고 숫자형, 문자열, 객체, 배열 등 모든 데이터 형식을 의미한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;하나의 변수명(식별자)을 선언하면 메모리에 해당 변수명을 위한 공간이 생긴다. 변수명은 그 메모리를 고유하게 인식하게 만드는 식별자인 것이다. 변수명에는 할당된 값을 직접적으로 저장하는 것이 아니라 값이 할당된 메모리 주소를 기록하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;불변값-가변값-복사&quot;&gt;불변값, 가변값, 복사&lt;/h3&gt;

&lt;p&gt;위에서 자바스크립트의 기본형 데이터 타입은 값이 변하지 않는 불변성을 띈다고 말했다. 변수에 새로운 값을 할당하려고 하면 메모리에 새로운 데이터 공간을 만들어서 저장하고 그 데이터 공간의 주소를 변수명에 변경해준다. 완전히 새로운 값의 주소를 반영해주는 것이다. 그래서 &lt;strong&gt;‘불변’한다&lt;/strong&gt;고 표현한다. 한 번 만들어진 기본형 데이터 값은 새로 만드는 동작을 통해서만 변경을 진행한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참조형 데이터는 무언가 ‘가변값’일 것 같다. 참조형 데이터를 컴퓨터가 어떻게 처리하는지 아래의 아주 간단한 코드를 뜯어보면서 알아보자. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;특정 주소에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj&lt;/code&gt;라고 하는 식별자 주소를 만든다. 이 변수명에 담길 프로퍼티가 여러개라는 것을 인식하게 된다.&lt;/li&gt;
  &lt;li&gt;다양한 프로퍼티의 변수를 인식할 새로운 변수 영역 주소를 새롭게 생성한다. 여기서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;에 대한 부분을 위한 주소값 생성이다.&lt;/li&gt;
  &lt;li&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string&lt;/code&gt;을 저장할 데이터 영역 주소를 따와서 프로퍼티 변수 주소에 반영해준다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj&lt;/code&gt; 주소에는 프로퍼티 변수들의 주소값이 할당된 주소를 반영해준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;복사에서도 기본형과 참조형은 차이를 보인다. 결론부터 이야기하면 기본형과 참조형 모두 ‘주소를 참조’한다. 다만, 기본형을 복사하여 값을 변경하면 ‘주소’가 새롭게 변경되는 것이고 참조형을 복사하여 내부 프로퍼티의 값을 변경하면 내부값을 담고 있는 주소는 변경되지 않지만 내부의 저장된 값의 주소들이 변경되는 것이다. 결국 참조형의 복사는 그릇의 주소가 변경되지 않기 때문에 기본적인 복사로는 불변성을 지킬 수 없다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 동일한 데이터 영역 주소 참조&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 동일한 객체 변수 영역 주소 참조&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 완전하게 새로운 데이터 영역 주소 참조&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 객체 변수 영역의 주소는 동일하지만 c의 데이터 영역 주소만 변경된다.&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// a !== b&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// obj1 === obj2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/core-javascript/data-duplicate.png&quot; style=&quot;width: 80%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참조형 데이터가 ‘가변값’이라고 설명하기 위해서는 참조형 데이터 자체의 주소를 변경하는 경우가 아니라 그 내부의 프로퍼티 값들에 대한 주소를 변경할 때에만 성립한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/core-javascript.jpeg&quot; style=&quot;width: 80%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="js" /><category term="series" /><category term="book" /><summary type="html">이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.</summary></entry><entry><title type="html">📚 프로덕트 오너(Product Owner)를 읽고</title><link href="https://hankyeolk.github.io/2021/04/08/book-productOwner.html" rel="alternate" type="text/html" title="📚 프로덕트 오너(Product Owner)를 읽고" /><published>2021-04-08T00:00:00+09:00</published><updated>2021-04-08T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/04/08/book-productOwner</id><content type="html" xml:base="https://hankyeolk.github.io/2021/04/08/book-productOwner.html">&lt;h2 id=&quot;intro&quot;&gt;Intro.&lt;/h2&gt;

&lt;p&gt;한 달에 적어도 8번 정도는 쿠팡의 로켓와우 서비스를 사용한다. 새벽배송을 넘어 출근하면서 주문한 딸기를 퇴근하면서 바로 먹을 수 있는 당일배송까지 책임진다. 배달의민족 앱을 터치한 것이 얼마나 먼 옛날인지 상상도 안 된다. 이제는 쿠팡이츠로만 배달 해먹는다. 필요한 물건이 있으면 쿠팡으로만 검색하고, 로켓배송이 안 되는 물건은 당장 필요없는 것이라고 의사결정한다. 쿠팡이라는 한 브랜드가 내 소피 패턴을 완벽하게 바꿔 놓았다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;나만 이렇게 생각하지는 않는 것 같다. 철저하게 쿠팡의 서비스만 고용하는 소비자가 주변에 심심치 않게 보인다. 어떻게 쿠팡은 나를 ‘쿠팡 의존자’로 만들 수 있었을까?에 대한 답이 이번에 읽은 책, &lt;strong&gt;프로덕트 오너(PO)&lt;/strong&gt;에 담겨있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;정답부터-말하자면&quot;&gt;정답부터 말하자면,&lt;/h2&gt;

&lt;p&gt;철저하게 프로덕트 중심으로 생각하고, 어떻게 하면 고객이 우리 서비스를 고용하게 만들지만 고민하는 사람이라고 프로덕트 오너를 짧게 정의 할 수 있겠다. 여기서 고객은 당연히 서비스 외부에서 앱 아이콘을 단순하게 터치하는 사람부터 그 범위에 포함된다. 서비스 내부에서 운영하고 에프터 서비스를 하고 심지어 물류를 관리하는 사람도 고객으로 볼 수 있다. 고객을 분류하고 각각의 부류에 어떤 가치를 전달해야 하는지를 정하는 것이 프로덕트 오너의 대표적인 업무다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;책의 저자분(쿠팡의 유명한 김성한 프로덕트 오너)는 고객이 어디에 있든, 현장에 있거나 공장에 있거나 전화상으로 의견을 전달하는 고객에게 마저 집착하는 것을 강조한다. 그리고 그런 집착을 주변 동료에게 전파하는 역할까지 프로덕트 오너의 주 업무라고 전한다. 개인 추천이 핵심인 넷플릭스, 쿠팡의 서비스가 이런 집착에서 빌드된 것이지 않을까 한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;단순하게 고객의 불편만 집착해서 개선하는 쪽으로 생각하는 것은 아니다. 고객이 느끼는 불편 사항이 어떻게 우리의 서비스의 고용으로 해결되는지 끊임없이 분석하는 것이 프로덕트 오너의 일이고, 그것이 프로덕트의 존재 이유라고 말한다. IT 기반의 서비스는 정말로 소비자가 ‘고용’하는 것이 맞다고 생각한다. 누군가가 오프라인에서 해줄 수 있는 일을 작은 기기에서 대신해주고 있기 때문이다. 그런 서비스를 만드는 것 자체에 담긴 고민이 ‘고용’을 이끌어내는 것으로 책에서는 표현된다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;고객에게-집착하기는-하지만&quot;&gt;고객에게 집착하기는 하지만,&lt;/h2&gt;

&lt;p&gt;회사가 정한 목표와 방향성을 절대 잃어버리면 안 되는 것이 프로덕트 오너가 주의할 점이다. 고객만 쫓아서 시선이 고정되면 프로덕트를 지탱하는 회사의 의지와 시선을 잃어버리기 쉽다. PO가 사업적 관점을 유지하고 경영진의 시각을 이해해야 더 치열하게 고객에게 집착하기 위한 일의 우선순위를 정하기 쉽다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;일의 우선순위는 당연하듯이 데이터를 기반으로 정해야 한다. 의사 결정은 말할 것도 없다. 매번 PO가 남기는 결정은 프로덕트와 회사 자체에 엄청난 영향을 준다. 그렇기 때문에 PO에게 직관은 멀리해야 하는 생각이다. 최대한 이성적으로 판단하고 데이터 기반으로 사고해야 한다. 직관마저 데이터를 기반해야한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;책을-읽어가면서-그리고-일고-나서&quot;&gt;책을 읽어가면서, 그리고 일고 나서.&lt;/h2&gt;

&lt;p&gt;회사에서 데이터를 접할일이 정말 많다. 직접 유저 데이터를 쌓는 경우도 있다. 어떤 데이터부터 찾아서 업무에 적용해봐야 할 지 모르겠다면 ‘목표’부터 수치화 하는 것을 연습을 하면 좋다. 나도 이 사실을 알게 된 것이 정말 얼마 안 된다. ‘프로덕트 오너’ 책을 읽고 있을때, 회사에서 매일 아침 일찍 오시는 다른 팀의 담당자님과 대화를 할 때 배웠다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;목표를 수치화 하는 것은 간단하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;어제의 지표를 20% 당장 30%로 올릴 수 있는 00 일을 진행해보겠다.&lt;/code&gt; 정도면 충분하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이 업무에서 00 일로 인해서 15번의 불만이 접수되었는데, 00 부분을 개선해서 8번으로 조정하겠다.&lt;/code&gt;도 괜찮다. 중요한 것은 내가 ‘수치’와 ‘데이터’를 기반으로 누군가에게 말할 수 있는 것 그 자체다. 그런데, 말은 이렇게 하지만 당장 데이터를 기반으로 말하고 사고하는 것은 힘들다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;그러면, 야구를 생각하면 된다. 내가 좋아하는 어떤 스포츠라도 상관 없다. 나는 야구를 좋아하는데, 한창 좋아할 때는 스타팅 라인업 9명 타자의 모든 타율을 다 외울 정도였다. 그러면 된다. 이 정도까지도 사실 필요없다. A라고 하는 선수가 데이터 통계적으로 보통 2할 8푼을 친다고 가정한다면 그 가정이 머리에 들어와서 누군가에게 전달할 정도만 데이터를 우선 접근하면 된다. 중요한 것은 ‘수치’와 그걸 기반하는 ‘데이터’다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;p&gt;이 책을 읽으면서 누군가에게 내가 지금 하고 있는 일을 설득시키는 과정에 대해 많이 배울 수 있었다. 6페이저(6-page)까지는 아니더라도, 내가 지금 어떤 프로젝트를 하고 있으며 어떤 비용을 투입해서 어떤 것을 기대하고 있는지가 자세히 기록된 기획서를 반드시 세우는 과정이 중요하다. 그 문서만으로 상대를 설득할 수 는 없지만 설득시킬 가능성은 높일 수 있다. 나 스스로가 그 일을 하는 것에 대한 목적성을 가지는 데에도 설득력이 높아진다. 지금 하고 있는 일이 나를 왜 고용해야 하는지 계속 질문하자.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;또한, 5단계의 질문까지는 아니더라도 최소 3번의 why는 외치고 일을 시작하게 되었다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지금 하고 있는 일이 무엇을 위해서 하는 일인가? 그러면 거기서 파생하는 또 다른 질문의 답은 무엇인가? 그러면 최종적으로 이 사소한 부분은 어떻게 생각하는가?&lt;/code&gt; 식으로 하나의 일에 꼬리를 무는 질문을 하면된다. 쉽지 않다. 주어진 일을 하는 것도 힘들 수 있다. 그렇지만 why를 가지지 않으면 일을 하는 것에 반드시 한계가 온다. 물론 책에서도 이런 스스로에 대한 질문의 단계를 강조한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;그래서-프로덕트-오너가-되고-싶은거야&quot;&gt;그래서, 프로덕트 오너가 되고 싶은거야?&lt;/h2&gt;

&lt;p&gt;프로덕트 오너에 대한 바람을 불어넣는 책은 절대 아니었다. 그렇다고 프로덕트 오너라는 직업이 있다 정도만 알려주는 책도 아니었다. 김성한님의 ‘프로덕트 오너’ 책은 스타트업이든 아니든 ‘프로덕트/서비스’ 기반의 회사를 다니는 모든 주니어가 가지면 좋을 생각의 방향성과 업무 처리 방식을 전달하는 것을 목적으로 가진 것 같다. 우리 시절의 수학의 정석이나 지금 나에게 자바스크립트 딥다이브 같은 책상에 두고두고 흔들릴 때마다 볼 수 있는 기본서 같다. 물론 읽고 실천하지 않으면 따라오는 미라클은 없을 것 같은 단호함도 있다. 지금 당장 업무에 써먹겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210408/productOwner.jpeg&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="book" /><summary type="html">Intro.</summary></entry><entry><title type="html">혹시라도 누군가가 새로운 맥(Mac)을 사준다면..</title><link href="https://hankyeolk.github.io/2021/03/20/onSettings.html" rel="alternate" type="text/html" title="혹시라도 누군가가 새로운 맥(Mac)을 사준다면.." /><published>2021-03-20T00:00:00+09:00</published><updated>2021-03-20T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/03/20/onSettings</id><content type="html" xml:base="https://hankyeolk.github.io/2021/03/20/onSettings.html">&lt;blockquote&gt;
  &lt;p&gt;저의 개발 환경은 다음과 같습니다. &lt;br /&gt;
사이드 및 공부 : MacBook-Pro-16 2019, Big Sur 11.1 &lt;br /&gt;
업무 : MacBook-Pro-13 2020, Catalina 10.15.7 &lt;br /&gt;
집에서 가지고 놀기 : Mac Mini M1, Big Sur 11.1 &lt;br /&gt;
이번 블로그는 인텔 기반의 맥을 대상으로 합니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;before-개발-공부&quot;&gt;Before 개발 공부&lt;/h3&gt;

&lt;p&gt;대학생 시절 사용했던 맥북프로에서 ‘터미널앱(terminal)’을 열어볼 일이 딱 한 번 있었다. 맥북을 나보다 일찍부터 사용했던 친누나와 함께 카페에서 공부를 할 때였다. 우연하게 누나 맥북을 봤는데, 런치패드에 앱 아이콘들이 작은 크기로 오밀조밀하게 잘 배치가 된 모습을 마주하고 내 것에도 해달라고 한 것이 그 시작이었다. 누나는 자연스럽게 터미널앱을 열더니 몇 가지 명령어(?)를 입력하고는 트랙패드에서 다섯 손가락을 오므렸다. 나의 맥북 런치패드도 동일하게 앱 아이콘들이 작은 크기로 오밀조밀 잘 모여있었다. 신선한 충격 뒤로는 터미널을 열기까지 아마 2년은 걸린 것 같다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210320/launchpad.png&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;위의 사진처럼 내가 새로운 맥을 사거나 또는 누군가에게 받으면 가장 먼저하는 일이 런치패드의 아이콘 사이즈를 줄이는 것이다. 디폴트로는 앱 아이콘들이 나에게는 너무 크다고 판단되어서 조금 귀찮지만 가장 먼저 해준다. 이렇게 만드는 방법은 아래의 명령어를 터미널앱에서 순서대로 입력하면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rows&lt;/code&gt;는 런치패드에 격자를 나눈다고 했을때 생성할 행의 갯수다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;columns&lt;/code&gt;는 반대로 열의 갯수를 의미한다. 사진에서 보면, 한 줄(행)에 7개의 앱 아이콘이 배치된 것을 알 수 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;defaults write com.apple.dock springboard-rows &lt;span class=&quot;nt&quot;&gt;-int&lt;/span&gt; 12
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;defaults write com.apple.dock springboard-columns &lt;span class=&quot;nt&quot;&gt;-int&lt;/span&gt; 7
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;killall dock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;github을 알기 시작하고 jekyll과 jQuery로 블로그를 만들 때 다시 터미널을 열어야 했다. homebrew(홈브루)&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;로 루비를 설치하고 git을 연결해주는 작업만 정말 하루 종일 검색하면서 진행했었다. 블로그를 구축한 다음에도 git 명령어를 통해서 포스팅하는 작업을 위해 터미널을 열었었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;이-블로그를-쓰는-목적&quot;&gt;이 블로그를 쓰는 목적&lt;/h3&gt;

&lt;p&gt;개발 공부를 시작하고 나서는 더 많은 것들을 맥에 세팅해주어야 했다. 이 설정들은 지금도 새로운 맥을 얻게 된다면 개발 환경 구축을 위해서 매번 해준다. 사실 이 블로그를 작성하는 가장 주요한 목적이 지금부터다. 매번 까먹기 때문에 더 이상의 검색을 하지 않고 바로 블로그로 확인하기 위해서!&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;1-iterm2-설치와-homebrew-oh-my-zsh-설정&quot;&gt;1. Iterm2 설치와 Homebrew, oh-my-zsh 설정&lt;/h3&gt;

&lt;p&gt;그렇다. 맥에서 기본적으로 제공하는 터미널앱은 이제 이쁘지가 않다. 나는 &lt;a href=&quot;https://iterm2.com/&quot;&gt;Iterm2&lt;/a&gt;를 사용한다. macOS 10.14 버전 이상부터 지원하는 터미널앱이고 다양한 테마를 사용할 수 있다! (쑤아리-📣) 그리고 다양한 개발 프로그램을 설치할 수 있게 도와주는 Homebrew를 설치한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;Homebrew 설치 전에 Iterm2를 실행시키면 똑똑한 맥이 auto-install을 통해서 개발환경을 구축하냐고 묻는다. 그때 확인 버튼을 누르면 xcode와 관련된 설치가 진행된다. (xcode 자체를 설치하는 것은 아니다!) 그런데, 중고로 맥을 사면 이 auto-install 팝업이 뜨지 않는 것도 같았다. 그럴때는, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ xcode-select --install&lt;/code&gt;로 개발 환경을 구축할 수 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;는 공식문서 가장 상단에 설치 코드가 있다. 그 코드를 복사해서 터미널에 붙여넣으면 끝난다. M1칩이 들어간 맥미니에서 Homebrew를 설치할 때 애를 먹긴했다. 로제타로 우회해서 설치하고 나중에 nvm 설정을 잡아줄 때도.. 우선 M1에 대한 내용은 다음에 정리하기로 하자.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;Homebrew 설치가 완료되면 이제 Iterm에 새로운 옷을 입혀줘야 한다. Homebrew를 굳이 먼저 설치할 필요는 없지만, wget을 사용할 것이라면 있는 것이 좋다. wget은 url을 기반으로 파일을 다운받는 프로그램이다. wget을 이용해서 Iterm에 &lt;a href=&quot;https://ohmyz.sh/#install&quot;&gt;OH-MY-ZSH&lt;/a&gt;를 한다. 역시 공식문서에 설치 관련 설명이 잘 되어있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;wget
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; -&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;2-oh-my-zsh에-이쁜-테마-입히기&quot;&gt;2. oh-my-zsh에 이쁜 테마 입히기&lt;/h3&gt;

&lt;p&gt;oh-my-zsh는 정말 다양한 테마를 제공한다. 그 중에서 나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;agnoster&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fletcherm&lt;/code&gt;을 사용하는데 정말 다양한 &lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&quot;&gt;테마&lt;/a&gt;가 있기 때문에 맘에 드는 것을 찾아서 사용하면 된다. 테마 변경은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt; 파일에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZSH_THEME=&quot;여기에 원하는 테마를 입력하세요&quot;&lt;/code&gt;에 반영하면 된다. 구글에 검색하면 정말 많은 oh-my-zsh 테마를 다루는 방법을 찾을 수 있다. 😀&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano ~/.zshrc
&lt;span class=&quot;nv&quot;&gt;$ ZSH_THEME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fletcherm&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 반영한 다음에는 ctrl + x -&amp;gt; ctrl + y -&amp;gt; enter 로 저장하고 나온다!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;3-vscode-설치하고-path-설정에서-code-명령어-먹이기&quot;&gt;3. VSCode 설치하고 Path 설정에서 code 명령어 먹이기&lt;/h3&gt;

&lt;p&gt;역시 그렇다. VSCode를 주력 에디터로 사용하면 모든 문서, 코드 작업을 거기서 하게된다. &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode&lt;/a&gt;를 설치하고 열어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmd shift P&lt;/code&gt;를 누르면 어떤 검색창 같은 것이 에디터 상단에 나온다. 그 검색창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt;를 입력하면 터미널창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code .&lt;/code&gt; 명령어로 VSCode를 열수 있게 등록하는 액션이 나오는 것을 경험할 수 있다. (아래 사진 참고!)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210320/vscode.png&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;4-git-alias-등록하고-git-editor-기본-설정하기&quot;&gt;4. Git Alias 등록하고 git, editor 기본 설정하기&lt;/h3&gt;

&lt;p&gt;Iterm으로 주로 git 명령어를 많이 활용한다. 그 과정에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit -m&lt;/code&gt; 등과 같은 길고 번거로운 명령어를 매번 입력하기 귀찮아서 oh-my-zsh에 등록해서 사용중이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code . ~/.zshrc&lt;/code&gt;를 입력해서 VSCode에서 쉽게 zsh 설정을 변경해주자.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# .zshrc 파일&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;gl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;git log --graph --decorate --oneline --all&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;gs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;git status&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clear&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mysql -u root -p&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;주로 위의 단축형 alias를 설정한다. 더 많지만 다 적기에는 너무 커스텀화 되어 있어서 소개하기 애매했다. 파일에 등록한 alias는 Iterm2에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt; 명령어를 입력해서 적용해 줄 수 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;그 다음에 내 컴퓨터에서 버전 관리를 목적으로 사용하는 git과 터미널에서 사용할 에디터의 기본값을 설정해준다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.name &lt;span class=&quot;s2&quot;&gt;&quot;hankyeolk&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.email &lt;span class=&quot;s2&quot;&gt;&quot;email@email.com&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--glboal&lt;/span&gt; core.editor &lt;span class=&quot;s2&quot;&gt;&quot;nano&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;5-nvm으로-nodejs를-설치해주면-끗&quot;&gt;5. NVM으로 Node.js를 설치해주면 끗!&lt;/h3&gt;

&lt;p&gt;나는 Node.js를 활용해서 웹 개발을 하는 개발자다. 그렇기 때문에 Node의 버전을 쉽게 관리하도록 도와주는 NVM의 설치는 필수적이다. NVM 역시 wget으로 손쉽게 설치할 수 있다. 아래의 코드로 설치가 잘 된다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvm --version&lt;/code&gt; 명령어를 입력했을 때 하단에 버전이 잘 뜰 것이다!&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget &lt;span class=&quot;nt&quot;&gt;-qO-&lt;/span&gt; https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;그런데 종종 nvm을 설치하다 보면 설치 도중에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvm is already installed&lt;/code&gt;라고 하는 벼락과 같은 문구가 뜰 수 있다. 그럴때는 당황하지 말고 아래의 방법을 시도해보자! nvm에 대한 설정이 export 되지 않아서 발생하는 경우가 거의 대부분이다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano ~/.zshrc

&lt;span class=&quot;c&quot;&gt;# nano&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;NVM_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;XDG_CONFIG_HOME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; %s &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;HOME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/.nvm&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; %s &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;XDG_CONFIG_HOME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/nvm&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NVM_DIR&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/nvm.sh&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NVM_DIR&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/nvm.sh&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# ctrl + x -&amp;gt; ctrl + y -&amp;gt; enter&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;NVM이 잘 설치됐다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvm install 14.16.0&lt;/code&gt; 등의 방식으로 Node.js를 설치하고 사용하면 된다. 나는 보통 LTS 버전을 우선적으로 설치하고 그 다음에 Current 버전을 설치해서 사용한다. 개발은 Current 버전을 이용한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;p&gt;새로운 맥을 어떻게든 얻게된다면 더 이상 찾아보는 수고를 하지 않고 이 블로그를 참고해야겠다. 새로운 맥이 언제 생길지 모르겠지만 그렇게 하자! 😆&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;hr /&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;mac os에서 사용하는 패키지 매니저. GUI의 도움 없이 프로그램을 설치하고 제거할 수 있게 도와주는 역할을 한다. 웹상에서 존재하는 운영체제에 맞게 제작된 프로그램을 내 컴퓨터에 쉽게 설치하기 위해 도와준다. 맥에서는 homebrew가 그 패키지 매니저 역할을 한다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>hankyeolk</name></author><category term="etc" /><summary type="html">저의 개발 환경은 다음과 같습니다. 사이드 및 공부 : MacBook-Pro-16 2019, Big Sur 11.1 업무 : MacBook-Pro-13 2020, Catalina 10.15.7 집에서 가지고 놀기 : Mac Mini M1, Big Sur 11.1 이번 블로그는 인텔 기반의 맥을 대상으로 합니다!</summary></entry><entry><title type="html">원정대를 성공적(?)으로 마무리하면서.</title><link href="https://hankyeolk.github.io/2021/02/27/databaseExpedition.html" rel="alternate" type="text/html" title="원정대를 성공적(?)으로 마무리하면서." /><published>2021-02-27T00:00:00+09:00</published><updated>2021-02-27T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/02/27/databaseExpedition</id><content type="html" xml:base="https://hankyeolk.github.io/2021/02/27/databaseExpedition.html">&lt;blockquote&gt;
  &lt;p&gt;주의. 이번 블로그는 반지의 제왕 덕후적인 용어들이 제법 나옵니다. 그냥 덕후구나 하고 넘어가주세요. 🧙‍♀️&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;내가 지금 다니고 있는 회사에는 ‘원정대’라는 업무 조직이 있다. “원정대?”라고 생각이 들 수 있다. 그런데 그 생각과 더불어 영화 ‘반지의 제왕’의 그 &lt;strong&gt;&lt;em&gt;반지 원정대&lt;/em&gt;&lt;/strong&gt;가 생각난다면 정확하게 맞다. 선택받은 호빗 ‘프로도’와 간달프, 아라곤 등등이 팀을 꾸려서 모르도르의 산으로 절대반지를 옮기는 그 반지 원정대처럼 선택 받은 (개인의 선호도가 정말 많이 반영된) 구성원들이 자유롭게 TF팀을 구성하는 것을 &lt;strong&gt;‘원정대’&lt;/strong&gt;라고 부른다. 어제까지해서 나도 하나의 절대 반지를 성공적으로 모르도르로 옮길 수 있었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;원정대가-리벤델에서-킥오프로-시작하다&quot;&gt;원정대가 리벤델에서 킥오프로 시작하다.&lt;/h3&gt;

&lt;p&gt;원정대가 발대하면서 킥오프 미팅을 진행했다. 원정대원들과 기존 컨텐츠에 대한 피드백을 주고받는 것으로 시작되었다. 컨텐츠 제작자의 피드백과 실제 소모자들의 피드백에는 차이가 있는 경우가 대부분이기 때문이다. 정말 살벌하게 피드백했다. 우리가 새롭게 디자인할 컨텐츠는 어떤 피드백을 받을 수 있을지 궁금해하면서 쳐낼 것은 쳐내고 남길 것은 무엇인지 깊게 논의했다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;피드백에는 항상 공통점이 있다. 그 공통점이 좋은 쪽으로 “맞아 맞아” 하면서 더 좋은 쪽으로 개발되도록 공유되기도 하지만, 보통은 “맞아, 그거 불편해요”가 더 많다. 킥오프에서 나왔던 공통점들도 그랬다. 그래서 기존 컨텐츠를 전체적으로 들어내고, 다른 컨텐츠에 새로운 FILL ME IN을 넣는 방향성을 정했다. 원정대가 모르도르에 도착해야 하는 시기(due-date)가 그렇게 길지 않았기 때문에 스프린트에서 집중적으로 고민해봐야 할 내용을 중점으로 개선 포인트를 잡았다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;헬름-협곡에서-계속해서-삽질을-반복했다&quot;&gt;헬름 협곡에서 계속해서 삽질을 반복했다.&lt;/h3&gt;

&lt;p&gt;원정대 일정 중간에 설 연휴가 있었다. 그래서 연휴 전까지 기존 컨텐츠의 부채를 해결하기로 했다. 플랫폼에서 컨텐츠 자체를 수정하면서 연휴를 기다렸는데, 연휴 이후에 남은 일정이 그렇게 많아 보이지 않았다. 프로도와 샘이 골룸을 만난 느낌이었다. 이 시기에 내가 새로운 컨텐츠도 만들고 피드백도 받고 개선하고 배포하는 전체적인 과정을 다 할 수 있을까 하는 의심이 생겼다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;원정대 대원에게 긴급하게 콜을 했고, 업무를 빠르게 분담했다. 코스 동기이자 입사 동기인 크루가 함께하는 원정대원이라 편하게 정할 수 있었다. 나는 영어로 적혀있는 컨텐츠를 교육 자료로 사용될 수 있게 번역하는 업무를 배정받았다. 외국 개발자들이 적어둔 양질의 컨텐츠를 번역해서 공부하는 개발자가 많아서 나도 한 번 해보고 싶었다. 그리고 현실로도 너무 공부가 많이 됐다. 한 문장을 번역하면 이해해야 할 것이 쏟아졌기 때문이다. 컨텐츠 번역을 시작하면서 우리 원정대는 헬름 협곡에 들어갔다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;설 연휴에 부산 본가를 내려가지 않기로 결정을 내리면서 오랜만에 Express로 서버 코드를 작성했다. 원정대의 서버가 Express.js를 기반으로 MySQL 데이터베이스 서버를 연결해야 했기 때문이다. 라우팅을 나누고 MVC 패턴을 기반으로 Model의 Query 요청 메서드, Controller의 요청, 응답 메서드를 구분했다. HTTP 응답 코드가 애매해서 일단 409로 에러를 날렸는데, 이후에 원정 대장님이 잘 찾아보고 알맞는 에러를 알려주는게 좋다고 바로잡아 주셨다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원정 대장님은 정말로 간달프다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;설이 지나고 본격적으로 코드를 논의했다. 내가 원정대 업무 말고도 다른 운영 업무에 관계된 부분이 많아서 정말 정신이 없었다. 그래도 다행스러웠던건 설이 지나자 기적처럼 정부가 거리두기를 2단계로 조정했다는 사실이다. 그래서 회사가 다시 오프라인 근무로 전환되었고 코드를 바로 바로 보면서 진행할 수 있었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;원정대에도 나즈굴과 같은 존재가 있었다. 나였다. 내가 나즈굴이었다. 원정대에 집중을 많이 못해서 내 동기가 혼자서 오크와 같은 에러들을 해결해야 했다. 헬름 협곡은 내 자리였고 사방에서 오크들이 밀려왔다. 실시간으로 코드를 비교하고 피드백하기 위해서 동기가 기존 자리를 벗어나 내 옆자리로 옮기는 모습이 헬름 협곡의 새벽을 연상캐했다. 원정대가 끝나가는 시점에 동기의 자리가 완전히 내 옆자리로 픽스된 걸 보면 우리가 정말 치열하게 협업한 건 맞나보다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;중간 중간 여러명의 간달프가 오고가서 컨텐츠 코드가 탄탄해지는 경험을 했다. 로우 쿼리를 오랜만에 작성해서 w3school로 공부했던 그 시절을 다시 떠올려보기도 했다. 여러번 입고 있던 미스릴 갑옷의 덕을 보기도 했다. (도대체 무슨 비유를 하고 싶은 건지 글을 적으면서도 잘 모르겠다. 촤하하)&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;이제-남은-것은-절대-반지-앞에서-이성을-잃지-않는-것&quot;&gt;이제 남은 것은 절대 반지 앞에서 이성을 잃지 않는 것.&lt;/h3&gt;

&lt;p&gt;원정대의 최종 기한이 다가오면서 내가 배정받은 세션이 부담되기 시작했다. 처음해보는 라이브 학습 세션이라 너무 긴장할 수 밖에 없었다. 문제를 작성하고 설명에 필요한 자료를 하나씩 준비했다. 이미지, 슬라이드, 스크립트를 차례로 준비하면서 1주일 내내 야근을 진행했다. 원정대원인 동기도 매일 늦게 퇴근하면서 나의 리허설, 세션, 그리고 본인의 세션을 열심히 준비했다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;대망의 세션날, 회사는 전사 리모트를 진행했다. 사무실에 출근하는 사람이 5명 정도였고 나도 그 중 하나였다. 3시 반 세션을 위해서 정말 쉬지 않고 스크립트를 읽었다. 실제로 진행하는 것처럼 시뮬레이션 하면서 진행했다. 그리고 모르도르의 용암에 절대 반지를 잘 던지고 나왔다. 막힘이 없지는 않았다. 하지만 분위기에 익숙해지니까 쉴 수가 없었다. 방음부스의 공기가 용암 근처의 뜨거운 열기처럼 달아올랐다. (소설을 쓰고 있네…)&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;원정대가-나에게-남긴-것&quot;&gt;원정대가 나에게 남긴 것&lt;/h3&gt;

&lt;p&gt;이번에 진행한 원정대 업무는 부담이 컸지만 즐거웠다. 그전까지 동기분과 말을 많이 해보지 못했는데, 원정대때 정말 말을 많이하고 수많은 피드백을 주고 받아서 개인적으로는 되게 많이 친해진 것 같다. 그리고 하나의 컨텐츠를 만드는 것에 직접 참여한 경험을 얻었다. 내가 만든 컨텐츠가 많은 수강생에게 소비되어 지식으로 남는 과정에 희열을 느꼈다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;다음에 또 다른 원정대를 하라고 하면 선뜻 “와 제가 무조건 하겠습니다”는 못 할 수 있겠지만 (이게 본심인가.. 🧙‍♀️) “하고 싶지 않습니다.”는 절대 나오지 않을 것 같다. 운영 업무쪽에서도 원정대를 꾸려야 할 부분이 많을 것 같아서 먼저 제안해보고 싶은 마음도 크다. 아라곤이나 간달프 같이 주요한 역할은 못 하더라도 김리, 피핀 정도는 할 수 있지 않을까 한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210227/expedition.png&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="work" /><category term="review" /><category term="database" /><category term="backend" /><summary type="html">주의. 이번 블로그는 반지의 제왕 덕후적인 용어들이 제법 나옵니다. 그냥 덕후구나 하고 넘어가주세요. 🧙‍♀️</summary></entry><entry><title type="html">누군가의 삶을 결정할 수 있다는 사실에 대해서</title><link href="https://hankyeolk.github.io/2021/02/21/recallthetime.html" rel="alternate" type="text/html" title="누군가의 삶을 결정할 수 있다는 사실에 대해서" /><published>2021-02-21T00:00:00+09:00</published><updated>2021-02-21T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/02/21/recallthetime</id><content type="html" xml:base="https://hankyeolk.github.io/2021/02/21/recallthetime.html">&lt;p&gt;한창 열을 올리며 업무에 매진하고 있던 금요일 오후 4시쯤, 어머니께 카톡을 하나 받았다. 평소에 업무 시간에는 아무리 급해도 잘 연락을 하시지 않는 어머니의 성향을 알고 있어서 조금 놀란 눈으로 톡을 읽었다. ‘아버지가 오늘로 학교와 이별을 하셨다.’는 단촐하면서도 묵직한 한 방(🥊)이 있는 문장은 뜨거운 감정을 불러 일으켰다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;서둘러서 아버지께 연락했다. 얼마나 긴 시간동안 교사라는 직업에 최선을 다하셨는지 알기 때문에 퇴직하는 날도 몰랐던 내 스스로가 너무 부끄러웠다. 아버지의 회신은 어머니의 것보다 더 뜨거웠다. ‘이제야 하나의 가정(家庭)에 더 집중 할 수 있어서 홀가분하다’고. 그동안 아버지가 책임졌던 누군가의 자식들에 대한 학습적인 삶의 결정의 순간들이 최선으로 가득했음을 너무 잘 느낄 수 있었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;운명처럼 아버지의 카톡을 받기 몇 분 전에 나는 누군가의 삶에 중요한 선택에 의견을 제시하는 업무를 진행했다. 수강생분들과 다채롭게 이야기를 하면서 그들의 고민을 듣고 내 생각을 말하는 업무였다. 그들의 이야기는 정말 만날때마다 다양하지만 결은 같았다. ‘불안과 두려움’ 처음 배우는 것들로 인해서 밀려오는 불안감을 나도 지난 5개월간 느꼈다. 그래서 공감을 펼친다. 그들이 혼자만 불안한 것이 아니라는 사실을 알려주고, 누구나 그 시점에서 두려운 것이 맞다고 알려준다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;그렇게 내 의견을 전달하면 보통의 상대들은 안심을 하거나 조금 더 고민을 해보고 내가 제시한 방향대로 선택한다. 우쭐하거나 하지 않는다. 오히려 그들이 내 생각대로 자신의 생각을 억지로 맞추는 것은 아닌가 하면서, 돌아서서 혼자 불안해한다. 종종 내가 말한 방향과는 거의 반대에 있는 의견을 말하는 수강생도 있다. 그분들에게는 스스로 고민한 내용이 얼마나 값진지 다시 알려주고 선택에 후회가 생기지 않을 수 있도록 또 다른 사례를 찾아 알려준다. 내가 할 수 있는 거라곤 선을 떠넘기는 정도다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;아버지와 통화하면서 ‘가족’을 위해 여러번의 선택의 길에 섰을 아버지 모습이 그려졌다. 누군가의 삶을 결정할 수 있다는 사실이 얼마나 두려운 일인지 요즘 정말 깊게 깨닫는 중이기에 37년간 고생하신 아버지가 지금 보다 더 커 보였다. 고생하셨습니다, 아버지.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="blog" /><category term="work" /><category term="review" /><summary type="html">한창 열을 올리며 업무에 매진하고 있던 금요일 오후 4시쯤, 어머니께 카톡을 하나 받았다. 평소에 업무 시간에는 아무리 급해도 잘 연락을 하시지 않는 어머니의 성향을 알고 있어서 조금 놀란 눈으로 톡을 읽었다. ‘아버지가 오늘로 학교와 이별을 하셨다.’는 단촐하면서도 묵직한 한 방(🥊)이 있는 문장은 뜨거운 감정을 불러 일으켰다.</summary></entry><entry><title type="html">📚 기록의 쓸모를 읽고</title><link href="https://hankyeolk.github.io/2021/02/13/book-writeDownsUsage.html" rel="alternate" type="text/html" title="📚 기록의 쓸모를 읽고" /><published>2021-02-13T00:00:00+09:00</published><updated>2021-02-13T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/02/13/book-writeDownsUsage</id><content type="html" xml:base="https://hankyeolk.github.io/2021/02/13/book-writeDownsUsage.html">&lt;h2 id=&quot;가벼운-독서-감상&quot;&gt;가벼운 독서 감상&lt;/h2&gt;

&lt;p&gt;두낫띵클럽과 배달의 민족 출신으로 유명한 이승희 마케터님의 책, ‘기록의 쓸모’를 읽었다. 책은 1월에 완독했다. 후기를 늦게 작성하는 이유는 정말 1월 막바지와 2월 초반이 많이 바빴음을 알려준다. 사실 핑계다. 🙊&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;사실 이 책이 출시됐을 때, 사당 파스텔시티에 있는 영풍문고에서 덥석 집어들고 계산대까지 갔었지만 구매를 못 했었다. 그 뒤로 읽고 싶은 책 리스트에 꾸준하게 적혀만 있었다. 직장을 옮기고 여유가 생겼고 무엇보다도 일을 더 잘하고 싶다는 생각이 마구 들고 있어서, 다시 이 책을 알라딘 중고 서점에서 열심히 찾았다. 그리고 지난 1월의 마지막날 다 읽었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;작가님이 얼마나 기록에 빠져있는지 명료하게 전달되는 책이었다. 단순히 종이에 연필을 이용해서 글의 형태로 적는 사전적인 의미의 기록만 하지 않았다. 내 주변에 있는 모든 도구를 이용해서 기록하는 것 자체를 즐기는 삶을, 내가 좋아하는 ‘문장’으로 잘 전달했다. 목표가 있는 기록과 습관이 된 기록을 얼마나 자신있게 소개하는지가 책 속속마다 드러난다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;책을 읽기 전에 마주했던 알라딘 모바일 앱의 &lt;em&gt;‘너무 뻔한 말들로 형용되고 있다..’&lt;/em&gt; 는 별점 리뷰로 책 구매를 망설인 것도 사실이다. 하지만 1회 완독한 그 시점에 책을 덮은 뒤의 감정은 &lt;strong&gt;&lt;em&gt;‘사회 초년생이 되기 전에 읽었으면 좋았겠다’&lt;/em&gt;&lt;/strong&gt; 였다. 리뷰는 주관적이라 받아들이는 것은 더욱 더 주관적으로 해석되는 것 같다. 그래서 나의 리뷰는 ‘쓰고 싶어진다’이다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;마킹하게-만든-책의-문장들과-나의-생각&quot;&gt;마킹하게 만든 책의 문장들과 나의 생각&lt;/h2&gt;

&lt;p&gt;이번 독후감 블로깅도 문장들을 줍줍했다. 기록하고 싶은 문장들을 소개하고 내 생각을 미약하게 붙여본다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;p.37 &lt;br /&gt;
우리는 모든 것을 볼 수 있고 모든 것에서 의미를 찾을 수 있다. 그리고 이 모든 것은 기록될 수 있다. 기록된 것을 작업이나 자신의 삶과 연결시킬 수 있다. 이를 실행이라고 한다. 관찰하고 실행하는 것. 그 사이를 이어주는 것이 기록이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;모든 행동은 목적과 의미가 있는 점으로 표현할 수 있다. 그 점들의 사이를 연결하는 선을 기록이라고 표현하는 문장이 잘 와닿았다. 그렇게 연결하는 선을 긋는 작업을 실행이라는 단어로 잘 비유한 문장이라고 생각한다. 나도 보통 일을 시작하기 전에 계획을 세우는 편이다. 그 때, 계획을 기록하지 않으면 실행하는 시점에 정확하게 기억 안나는 경우가 많다. 그래서 꼭 순간순간이라도 기록해서 기억하려고 노력하는 편이다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;p.62 &lt;br /&gt;
상대방에게 생각할 여지를 주자. 어떤 이유에서건 ‘빈틈’과 ‘여백’은 머릿속에 생각할 공간을 만들어준다. 생각할 빈틈을 주자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;나는 보통 상대가 말하는 중에 머리속으로 다음 답변이나 새로운 에피소드를 생각하는 편이다. 그래서 대화가 막힌다는 느낌을 사뭇 싫어하고 있었던 것 같다. 그런데 전혀 그럴 필요가 없었다. 이미 알고 있었을텐데 &lt;strong&gt;바쁘다 바빠 현대 사회&lt;/strong&gt;를 살아간다는 핑계로 티키타카가 잘 맞는 대화를 선호하게 된 경향이 있다. 내가 전하는 말에도 ‘여백’을 심어보는 연습을 해야겠다고 마음 먹었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;p.79 &lt;br /&gt;
고통이 기본값인 인생이기에 드물게 찾아오는 그 행복이 좋은 걸지도 모른다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;요즘 특히 공감되는 문장이다. 서울에 혼자 살면서 금전적인 고통이나 외로움으로 비롯되는 고통들이 일상화 되었기 때문이다. 그래서 업무 도중에 오는 친구의 전화가 그렇게 반갑더라. 그 짧은 순간에 행복을 느끼는 요즘이다. 그래도 행복은 드물게는 말고 주기적으로 와줬으면 좋겠다. 🙇‍♂️&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;p.128 &lt;br /&gt;
내가 풀어갈 인생이 객관식이길 바라는 사람이었다. 내가 고민하던 것들이 보기에 나열되어 있고, 그 안에 답을 찾고 OMR 카드에 옮긴 뒤 엎드려 쉴 수 있는 삶이길 바랬다. 가끔씩 수정 테이프로 답을 고치는 정도면 괜찮을 것 같았다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;답이 정해진 삶을 살아가는 것은 너무 무료하다고 생각한다. 삶이 그렇지 않다는 것을 알기 때문에, 정답을 찾아가는 식으로 살 수 없다는 사실이 두렵기는하다. OMR 카드를 아무리 뚫어지게 쳐다봐도 답이 보이지 않는 것처럼 삶도 객관식 문항으로 고대로 옮길 수가 없다는 작가님의 문장이 너무 마음에 들었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;중학교 때, 나만 그런 추억이 있는지 모르겠지만, 교실의 형광등을 2초 이상 바라보고 다시 OMR 카드의 못 채운 빈칸을 응시한 기억이 있다. 형광등신의 계시인지는 몰라도 항상 유독 한 칸에 형광등에서 옮겨온 붉은 빛이 머물러 있었다. 살아갈 때 그렇게 우연의 계시로 삶에 대한 정답이 보이면 좋겠다. 모든 순간에 말고.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;p.148, 224 &lt;br /&gt;
관찰은 다른 말로 하면 ‘사소한 것을 위대하게 바라보는 힘’이다. 영감을 얻으려면 집요하게 관찰해야한다. 무엇이 좋았는지 스스로와 대화를 나눠야 하며, 내 활동범위보다 더 넓게 더 많은 경험을 해야한다. ‘영감을 얻으려면 시간을 내야한다.’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;새로 일하고 있는 회사에서 담당한 일을 하나 처리하면 회고를 하는 문화가 있다. 다음에 비슷한 일을 할 때를 대비하는 목적도 있고, 스스로 모자란 부분을 파악해서 다른 이들에게 피드백을 받을 수 있다는 장점도 가지고 있는 문화다. 녹화된 영상을 다시 보면서 회고하는데, 처음 할때는 어찌나 오글거리던지 붙잡고 보는 것이 힘들었다. 그래도 다시 나를 관찰하니 보이지 않던 것이 제법 많이 불편하게 느껴졌다. 고칠 것 투성이인 스스로를 다 내려놓고 볼 수 있었다. 그래서 지금 이 회사의 문화와 동료들이 너무 마음에 든다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;그리고 나는 평소의 일상에서 느끼는 불편함을 기록하려고 노력한다. 대학교 시절, 창업과 관련된 수업을 들을때마다 교수님들이 주구장창 떠들었던 소리였다. ‘세상의 불편함을 느껴야 한다’고. 대학교에서 헛된 가르침만 얻은 것은 아닌가 싶다. 일상을 관찰하는 것의 유용함은 작년에 가장 즐겁게 읽었던 유병옥 카피라이터님의 책에서도 배울 수 있었다. 그리고 이 책에서도 다시 깨달았다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;이 책을 읽으면서 눈에 띄게 많았던 단어는 ‘행복’이었다. 행복은 단어가 생긴 것도 둥글둥글해서 아름다운데 얻었을 때의 기분도 너무 아름답다. 그래서 이 책을 읽는 순간이 행복했다. 수집한 문장 중에 가장 베스트라고 생각한 한 줄을 적으면서 이번 독후감 블로그도 마무리한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;“&lt;strong&gt;행복은 일회용 같아서 들었을 때 바로 써야해!&lt;/strong&gt;”&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210213/writeUsage.jpeg&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="book" /><summary type="html">가벼운 독서 감상</summary></entry><entry><title type="html">🧐 SQL과 NoSQL에 대해서 짧은 끄적임</title><link href="https://hankyeolk.github.io/2021/02/10/sqlvsnosql.html" rel="alternate" type="text/html" title="🧐 SQL과 NoSQL에 대해서 짧은 끄적임" /><published>2021-02-10T00:00:00+09:00</published><updated>2021-02-10T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/02/10/sqlvsnosql</id><content type="html" xml:base="https://hankyeolk.github.io/2021/02/10/sqlvsnosql.html">&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;목차&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#SQL&quot;&gt;SQL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#NoSQL&quot;&gt;NoSQL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#SQL과-NoSQL의-차이점&quot;&gt;SQL과 NoSQL의 차이점&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#SQL과-NoSQL-중에서-어떤-것을-사용해야-하나요?&quot;&gt;SQL과 NoSQL 중에서 어떤 것을 사용해야 하나요?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;데이터베이스는 크게 &lt;strong&gt;관계형 데이터베이스&lt;/strong&gt;와 &lt;strong&gt;비관계형 데이터베이스&lt;/strong&gt;로 양분된다. 관계형 데이터베이스는 &lt;strong&gt;SQL&lt;/strong&gt;을 기반으로 하고 비관계형 데이터베이스는 &lt;strong&gt;NoSQL&lt;/strong&gt;로 데이터를 다룬다. SQL과 NoSQL은 만들어진 방식, 저장하는 정보의 종류, 그리고 저장하는 방법 등에 차이가 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;관계형 데이터베이스는 구조화 되어있는 데이터베이스를 의미한다. 전화번호와 주소, 이름이 같이 적혀있는 전화번호부와 비슷한 &lt;em&gt;구조화된 스키마&lt;/em&gt;를 미리 작성해야한다. 이와 반대로, 비관계형 데이터베이는 구조화되지 않고, 분산되어있다. 컴퓨터에 생성한 하나의 폴더에 여러 사람의 주소나 전화번호, 쇼핑몰 주소등을 모두 담을 수 있는 형식과 비슷하다고 생각하면 편하다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;sql&quot;&gt;SQL&lt;/h2&gt;

&lt;p&gt;관계형 데이터베이스는 행(row)과 열(column)로 구성된 테이블에 데이터를 저장한다. 각각의 행은 하나의 속성에 대한 정보를 저장하고, 열에는 각각의 데이터 형식에 맞는 데이터가 저장된다. 관계형 데이터베이스에 저장되어 관리되는 데이터는 SQL이라고 하는 구조화된 쿼리 언어로 &lt;strong&gt;생성(Create), 조회(Read), 갱신(Update), 삭제(Delete)&lt;/strong&gt;의 행동을 진행한다. 대표적인 관계형 데이터베이스에는 &lt;em&gt;MySQL, Oracle, SQLite, Postgres, MariaDB&lt;/em&gt;가 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;nosql&quot;&gt;NoSQL&lt;/h2&gt;

&lt;p&gt;NoSQL 기반의 비관계형 데이터베이스는 보통 다음과 같은 타입으로 구성된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Key-Value 타입&lt;/strong&gt; : 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Key-Value&lt;/code&gt;의 쌍을 속성으로 하는 배열 형태로 저장한다. 여기서 &lt;strong&gt;Key&lt;/strong&gt;는 속성 이름을 뜻하고, &lt;strong&gt;Value&lt;/strong&gt;는 속성에 연결된 데이터 값을 의미한다. &lt;em&gt;Redis, Dynamo&lt;/em&gt; 등이 대표적인 Key-Value 형식의 데이터베이스다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;문서형(Document) 데이터베이스&lt;/strong&gt; : 데이터를 테이블이 아닌 문서처럼 저장하는 데이터베이스를 의미한다. JSON 유사 형식으로 데이터를 문서화한다. 각각의 문서는 하나의 속성에 대한 데이터를 가지고 컬렉션이라고 하는 그룹으로 묶어서 관리한다. 대표적인 문서형 데이터베이스에는 &lt;em&gt;MongoDB&lt;/em&gt;가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Wide-Column 데이터베이스&lt;/strong&gt; : 데이터베이스의 열(column)에 대한 데이터 관리를 집중하는 데이터베이스다. 각 열에는 key-value 형식으로 데이터가 저장되고, 컬럼 패밀리(column families)라고 하는 열의 집합체 단위로 데이터를 처리할 수 있다. 하나의 행에 많은 열을 포함할 수 있다는 유연성이 있다. 데이터 처리에 필요한 열을 유연하게 선택할 수 있다는 점에서 큰 규모의 데이터 분석에 주로 사용되는 데이터베이스 형식이다. 대표적인 wide-column 데이터베이스에는 &lt;em&gt;Cassandra, HBase&lt;/em&gt;가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;그래프(Graph) 데이터베이스&lt;/strong&gt; : 자료구조의 그래프와 비슷한 형식으로 데이터 간의 관계를 구성하는 데이터베이스다. 데이터는 노드(nodes)에 속성별(entities)로 저장된다. 각 노드간의 관계는 선(edge)으로 연결된다. 대표적인 그래프 데이터베이스에는 &lt;em&gt;Neo4J, InfiniteGraph&lt;/em&gt;가 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;sql과-nosql의-차이점&quot;&gt;SQL과 NoSQL의 차이점&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;데이터 저장(Storage)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;관계형 데이터베이스는 SQL을 이용해서 데이터를 테이블에 저장한다. 스키마를 기반으로 정해진 형식에 맞게 데이터를 저장한다.&lt;/li&gt;
  &lt;li&gt;NoSQL은 이와는 사뭇 다른 형태로 데이터를 저장한다. 위에서 설명된 것처럼, key-value, document, graph, wide-column 형식등으로 다양하게 데이터를 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 20px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스키마(Schema)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SQL을 사용하려면 형식이 고정된 스키마가 필요하다. 처리하려는 데이터 속성별로 열에 대한 정보가 미리 정해져야 한다는 의미다. 스키마는 나중에 변경할 수 있지만, 그럴 경우 전체 데이터베이스를 수정하거나 오프라인으로 전환할 필요가 있다.&lt;/li&gt;
  &lt;li&gt;NoSQL은 동적인 스키마를 기반할 수 있다. NoSQL로 즉시 열을 추가할 수 있고, 개별 속성에 대해서 모든 열에 대한 데이터를 반드시 입력하지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 20px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;쿼리(Querying)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쿼리는 데이터베이스에 대해서 정보를 요청하는 행동을 의미한다. 관계형 데이터베이스는 테이블의 형식과 테이블간의 관계에 맞춰서 데이터를 요청한다. 그래서 SQL과 같은 구조화된 쿼리 언어를 사용하는 것이다.&lt;/li&gt;
  &lt;li&gt;비관계형 데이터베이스의 쿼리는 데이터 그룹 자체를 조회하는 것에 초점을 둔다. 그래서 구조화 되지 않은 쿼리 언어로도 데이터 요청이 가능하다. UnQL(UnStructured Query Language)을 사용한다고도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 20px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;확장성(Scalability)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SQL 기반의 관계형 데이터베이스는 보통 수직적으로 확장한다. 데이터베이스가 구축된 하드웨어의 성능을 많이 이용하기 때문에 고비용이 든다. 복수의 서버에 걸쳐서 데이터베이스의 관계를 정의할 수 있지만 매우 복잡하고 시간이 많이 소모된다.&lt;/li&gt;
  &lt;li&gt;NoSQL로 구성된 데이터베이스는 수평적으로 확장된다. 많은 트래픽을 처리할 수 있도록 NoSQL 데이터베이스를 위한 서버를 추가적으로 구축할 수 있다는 의미다. 또한 저렴한 범용 하드웨어에 구축하거나 클라우드 기반의 인스턴스에 NoSQL 데이터베이스를 호스팅할 수 있어서 수직적 확장보다 비용 효율성이 높다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;sql과-nosql-중에서-어떤-것을-사용해야-하나요&quot;&gt;SQL과 NoSQL 중에서 어떤 것을 사용해야 하나요?&lt;/h2&gt;

&lt;p&gt;데이터베이스를 구축하는 방법을 선택하는 것에 완벽한 솔루션은 없다. 그렇기 때문에 많은 개발자들은 서비스에 맞고 유저의 요구를 충족하기 위해 관계형, 비관계형 데이터베이스를 모두 사용한다. NoSQL 기반의 비관계형 데이터베이스가 확장성이나 속도에서 뛰어나다고 해도 고차원으로 구조화된 SQL 기반의 데이터베이스가 더 좋은 성능을 보여주기도 한다. 여러 사용 사례를 살펴보고 적절한 데이터베이스를 선택하는 것이 중요하다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;sql-기반의-관계형-데이터베이스를-사용하는-케이스&quot;&gt;SQL 기반의 관계형 데이터베이스를 사용하는 케이스&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;데이터베이스의 ACID 성질을 준수해야 하는 경우&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ACID는 Atomicity, Consistency, Isolation, Durability 를 가리킨다. 각 단어는 데이터베이스 내에서 일어나는 하나의 상태 변화 수행(transaction)에 안전성을 보장하기 위해 필요한 성질이다. SQL을 사용하여 데이터베이스와 상호 작용하는 방식을 정확하게 규정할 수 있기 때문에 이상 징후를 줄이고, 데이터베이스의 무결성을 보호할 수 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;전자 상거래, 금융 서비스를 위한 소프트웨어 개발에서는 데이터베이스의 ACID 성질을 잘 준수해주는 것이 필수 옵션으로 되어있기 때문에 SQL을 이용한 관계형 데이터베이스를 사용한다. &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 20px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;소프트웨어에 사용되는 데이터가 구조적이고 일관적인 경우&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;소프트웨어(프로젝트)의 규모가 많은 서버를 필요로 하지 않고, 일관된 데이터를 사용하는 경우, 보통 관계형 데이터베이스를 사용한다. 이런 경우 다양한 데이터 유형과 높은 트래픽을 지원하도록 설계된 NoSQL 데이터베이스를 굳이 사용할 이유가 없다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;nosql-기반의-비관계형-데이터베이스를-사용하는-케이스&quot;&gt;NoSQL 기반의 비관계형 데이터베이스를 사용하는 케이스&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;데이터의 구조가 거의 또는 전혀 없는 대용량의 데이터를 저장하는 경우&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;대부분의 NoSQL 데이터베이스는 저장할 수 있는 데이터 유형에 제한을 설정하지 않는다. 필요에 따라서 데이터의 새 유형을 추가할 수 있다. 그렇기 때문에 소프트웨어 개발에 정형화 되지 않은 많은 양의 데이터가 필요한 경우, NoSQL을 적용하는 것이 효율적일 수 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 20px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클라우드 컴퓨팅 및 저장공간을 최대한 활용하는 경우&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;클라우드 기반으로 데이터베이스 저장소를 구축하면 저렴한 비용의 솔류션을 제공 받을 수 있다. 소프트웨어에 데이터베이스의 확장성이 중요하다면 여러 데이터 센터에 걸쳐서 많은 번거로움 없이 확장할 수 있는 NoSQL 데이터베이스를 사용하는 것이 좋다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 20px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;빠르게 서비스를 구축하고 데이터 구조를 자주 업데이트 하는 경우&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;NoSQL 데이터베이스의 경우 스키마를 미리 준비할 필요가 없기 때문에 빠르게 개발하는 과정에 매우 유용하다. 시장에 빠르게 프로토타입을 출시해야 하는 경우가 해당할 수 있다. 또한 소프트웨어 버전별로 많은 다운타임 없이 데이터 구조를 자주 업데이트 해야하는 경우, 관계형 데이터베이스는 스키마 수정 등으로 많은 어려움이 있다. 그럴때 NoSQL 기반의 비관계형 데이터베이스를 사용하면 좋다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;참고한 레퍼런스&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/nosql/document/&quot;&gt;문서형 데이터베이스&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mommoo.tistory.com/62&quot;&gt;데이터베이스 트랜젝션&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="backend" /><category term="database" /><summary type="html">목차</summary></entry></feed>