<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://hankyeolk.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hankyeolk.github.io/" rel="alternate" type="text/html" /><updated>2022-01-21T12:55:22+09:00</updated><id>https://hankyeolk.github.io/feed.xml</id><title type="html">HK Blog</title><subtitle>웹 개발자 강한결의 개발 블로그입니다.</subtitle><author><name>hankyeolk</name></author><entry><title type="html">노션으로 2022년 대시보드 만들기</title><link href="https://hankyeolk.github.io/2022/01/21/notiondashboard.html" rel="alternate" type="text/html" title="노션으로 2022년 대시보드 만들기" /><published>2022-01-21T00:00:00+09:00</published><updated>2022-01-21T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2022/01/21/notiondashboard</id><content type="html" xml:base="https://hankyeolk.github.io/2022/01/21/notiondashboard.html">&lt;p&gt;2022년 시작부터 나는 휴직을 결심했다. 일과 내 삶이 너무 붙어있었다. 그 둘을 떨어뜨리지 않으면 둘 중 하나는 크게 다칠 것 같다는 판단이 강하게 내려졌다. 2021년 하반기 동료 리뷰에 담긴 주요 키워드도 역시 &lt;strong&gt;‘분리’&lt;/strong&gt;였다. 그래서 1월의 첫 주, 나는 휴직모드로 들어갔다.&lt;/p&gt;

&lt;p&gt;첫 하루 이틀은 ‘쉬는 것이 무엇인지’를 몸 자체에 이해시키는 것에 집중했다. 2021년에는 ‘쉰다’는 키워드가 내 삶에 전혀 없었기에, ‘쉼’에 대한 정의가 무엇보다 중요했다. 그래서 나는 내 삶을 정리하고, 정리된 삶에서 앞으로 어떻게 살아야 할지를 고민해야 했다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가장 편하게 열어볼 수 있고, 이미 잘 쓰고 있으면서, 정리나 기록하고 나면 간지가 나는 플랫폼&lt;/strong&gt;이 필요했다. 직접 개발을 해볼까 싶기도 했지만, 노션의 앱 아이콘을 보자마자 ‘굳이?’ 라는 생각이 커졌다. 그래서 노션으로 삶 관리체계를 만드는게 정해졌다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;p&gt;노션으로 대시보드를 만들기로 결심하고 검색을 정말 많이했다. (아마 ‘notion dashboard’라는 키워드로 검색했던 것 같다.) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reddit&lt;/code&gt;에서 다양한 형태로 나름의 대시보드를 구축한 예시를 찾기 좋았다.&lt;/p&gt;

&lt;p&gt;그중에서 Red 라고 하는 이름으로 노션 전문 유튜브와 노션 블로그를 운영하면서, 노션 템플릿을 무료로 제공해주는 유저를 마주하게 되었다. 그녀의 &lt;a href=&quot;https://youtu.be/gwU0Sh-M0L4&quot;&gt;Tour of My 2022 Notion Dashboard&lt;/a&gt; 영상을 보면서 많은 부분을 참고했다.&lt;/p&gt;

&lt;p&gt;나는 노션 대시보드를 통해서 ‘온전한 나의 삶’을 꾸준하게 기록하는 목적을 달성하고 싶고, 이 글을 적는 지금도 내가 구축한 대시보드에 만족감을 크게 느끼고 있다. 아래에서는 대시보드에서 내가 설명하고 싶은 항목별로 어떤 특징을 가지고 있는지 간단하게 설명하고자 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 60px&quot;&gt; &lt;/p&gt;

&lt;h4 id=&quot;일상-루틴-관리&quot;&gt;일상 루틴 관리&lt;/h4&gt;

&lt;p&gt;가장 먼저 하루를 주 단위로 가볍게 관리하고 싶었다. 그래서 하루 중에 반드시 진행해야 하는 루틴(=습관) 트래킹 데이터베이스를 만들었다. 한 주를 살아보면서, 내가 반복적으로 수행하는 일이 있다면 습관 항목으로 만들어서 꾸준하게 관리할 수 있게 만드는 것이 이 데이터베이스의 핵심이다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 먼저 2022년의 전체 일정을 테이블에 반영했다.
&lt;img src=&quot;/img/posts/220121/weekTracking.png&quot; style=&quot;width: 80%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;월 ~ 일요일로 구성된 한 주만 체크해주는 Formula 속성을 작성했다. (내 생각에 Formula는 노션의 가장 큰 강점 중 하나다.)&lt;/p&gt;

    &lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;formatDate(prop(&quot;날짜&quot;), &quot;W&quot;) == formatDate(now(), &quot;W&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;매일의 감정을 기록하고, 습관을 체크하며, 한 줄 일기를 작성하는 습관을 만들고 싶었다. (나에 대해서 솔직하게 기록하고 싶었다.) 그래서 각 관리 항목을 속성으로 만들었다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;매일의 감정 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Select 속성&lt;/code&gt; / 기록하는 순간에 든 감정을 바로 선택할 수 있게 선택지를 미리 만들어뒀다.&lt;/li&gt;
      &lt;li&gt;습관들 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Checkbox 속성&lt;/code&gt; / 루틴이기 때문에 했다 or 안했다 만 관리할 수 있으면 된다고 생각하여 체크박스를 활용했다. 데이터베이스가 길어지는 것은 싫어서 이모지만 반영했다.&lt;/li&gt;
      &lt;li&gt;한 줄 일기 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text 속성&lt;/code&gt; / 말 그대로 하루에 가장 남기고 싶은 한 줄을 적고있다.&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대시보드 메인 페이지에서 ‘한 주’ 단위로만 보여지는 연결 데이터베이스(linked database)를 반영했다. 데이터베이스 필터에서 Formula로 설정한 값이 true 인 데이터만 불러오게 설정하면 된다.
&lt;img src=&quot;/img/posts/220121/thisWeek.png&quot; style=&quot;width: 100%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;주간 트래킹 데이터베이스는 하루를 시작할 때, 특정 습관적인 행동을 했을때, 그리고 자기 직전에만 관리하고 있다. 하루를 아주 간단하게 파악할 수 있어서 편하게 사용중이다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 72px&quot;&gt; &lt;/p&gt;

&lt;h4 id=&quot;2022년-목표-관리&quot;&gt;2022년 목표 관리&lt;/h4&gt;

&lt;p&gt;하루와 한 주간의 루틴 트래킹으로 ‘소소한 달성’을 이루어 낸다면, 2022년 목표 관리 데이터베이스는 ‘체계적인 달성’을 이루고 싶어서 만들게 되었다.&lt;/p&gt;

&lt;p&gt;2021년에는 ‘아 이것도 하고 싶은데’라던지 ‘아 이것도 해야 하는데’와 같은 &lt;strong&gt;생각으로만 머문 목표&lt;/strong&gt;가 제법 있었다. &lt;strong&gt;2022년은 생각으로만 머무는 목표를 만들고 싶지 않아서&lt;/strong&gt;, 나만의 목표를 관리할 수 있는 체계를 만든 것도 있다. (개인 OKRs 관리용으로도 사용할 수 있을 것 같다.)&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;목표 데이터베이스와 목표 달성을 위한 액션 데이터베이스를 각각 생성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;목표 데이터베이스의 핵심은 ‘연결된 액션의 달성 정도가 어떻게 되는지를 파악할 수 있는가?’ 였다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/posts/220121/target.png&quot; style=&quot;width: 100%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;‘목표 달성 정도’라고 하는 &lt;a href=&quot;https://www.notion.so/help/relations-and-rollups&quot;&gt;Rollup&lt;/a&gt; 속성을 하나 만들었다. 목표에 연결된 액션 중에서 ‘완료’ 처리가 된 액션의 비율을 보여 줄 수 있게 설정했다. 정말 쉽다!
&lt;img src=&quot;/img/posts/220121/rollups.png&quot; style=&quot;width: 50%; height: 60%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;
        &lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;목표 데이터베이스의 시작일을 등록하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 months&lt;/code&gt; 형식으로 예상 소요 기간을 입력하면 예상 종료일을 계산해주는 Formula 속성도 반영해두었다. (정확한 영어만 입력해야 해서 쓸모가 크진 않다.)&lt;/p&gt;

        &lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dateAdd(prop(&quot;시작일&quot;), toNumber(replace(prop(&quot;예상 소요 기간&quot;),
&quot;[A-z]&quot;, &quot;&quot;)), replaceAll(prop(&quot;예상 소요 기간&quot;), &quot;[ 0-9]&quot;, &quot;&quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;목표 달성을 위한 액션 데이터베이스는 위에서 만든 목표 데이터베이스와 ‘연결(=relations)’ 되는 것이 핵심이다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/posts/220121/action.png&quot; style=&quot;width: 100%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;완성된 목표 관리 데이터베이스를 대시보드 메인 페이지에 뽑아와서 갤러리 뷰로 보여지게 만들었다. 대시보드에서는 최대한 편하게 관리하는 것이 좋다고 생각해서 목표의 예상 마감일, 목표 현재 달성도만 보여지게 만들었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;목표, 액션 관리 데이터베이스를 구축으로 1주 ~ 1년 정도의 서로 다른 기간에 내가 달성해야 하는 목표의 체계성을 갖췄다는 사실이 가장 뿌듯하다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;이 글을 작성하는 것도 특정 목표의 달성을 위한 세부 액션이었다. 글을 다 작성하면 액션 하나를 완료처리 할 수 있어 너무 기쁘다.&lt;/em&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 72px&quot;&gt; &lt;/p&gt;

&lt;h4 id=&quot;글-작성과-카테고리별-모아보기&quot;&gt;글 작성과 카테고리별 모아보기&lt;/h4&gt;

&lt;p&gt;2022년에 가장 만들고 싶은 습관은 ‘꾸준한 글쓰기’다. 그래서 노션 대시보드 내부에 들어갈 항목을 정하면서 가장 먼저 그린 체계 역시 ‘글 적고 관리하기’ 였다.&lt;/p&gt;

&lt;p&gt;노션 데이터베이스에는 &lt;a href=&quot;https://www.notion.so/help/boards&quot;&gt;Board View&lt;/a&gt;라고 하는 칸반 형식의 멋진 태스크 관리 View가 있다. 글 작성 상태에 따라서 글을 편하게 옮겨다니며 관리할 수 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/220121/post.png&quot; style=&quot;width: 100%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;글 카테고리 - 카테고리 데이터베이스와 relation을 가지는 속성이다. 글 카테고리별로 편하게 모아보기 위해서 카테고리 데이터베이스를 구분했다.&lt;/li&gt;
  &lt;li&gt;발행? - 누군가에게 보여주고 싶은 글 vs 나만 볼 수 있는 글을 구분하고 싶었다. 그래서 발행? 속성이 true 인 값만 카테고리별로 모아보는 뷰에서 보여지게 세팅했다.&lt;/li&gt;
  &lt;li&gt;독후감? - 아래에서 설명할 독서 관리 데이터베이스와 relation을 가지는 속성이다. 책을 읽는 것에서 그치지 않고 다음에 쉽게 돌아볼 수 있게 기록하는 목적을 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/220121/postCategoryView.png&quot; style=&quot;width: 100%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 12px;&quot;&gt; &lt;/p&gt;

&lt;p&gt;작성된/중인 글마다 부여된 카테고리별로 모아 볼 수 있는 카테고리 데이터베이스를 따로 만들었다. 카테고리별로 몇 개의 글이 있는지를 보여주는 Formula도 가볍게 작성했다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;총 &quot; + format(length(replaceAll(prop(&quot;글&quot;), &quot;[^,]&quot;, &quot;&quot;)) + 1) +
&quot; 개의 글이 &quot; + prop(&quot;카테고리&quot;) + &quot; 안에 있습니다.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 72px&quot;&gt; &lt;/p&gt;

&lt;h4 id=&quot;독서-관리&quot;&gt;독서 관리&lt;/h4&gt;

&lt;p&gt;많은 사람들이 연초에 ‘올해는 n권의 책을 읽는다’ 라는 3일 유효기간도 가지 않는 (보통은..) 계획을 세운다. 나 역시 매년 초에 그랬고, 대부분은 소소한 달성조차도 못했던 것 같다. 독서라는 목표는 ‘미루기’라는 괴랄한 성질을 잘 이겨내야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;그래서 2022년에는 독서 자체를 대시보드로 관리해야겠다 싶었다. ‘n권을 읽자!’라는 뭉실한 목표가 아니라, ‘한 권이라도 관리해서 읽자’였다. 독서 관리 데이터베이스는 글 작성 데이터베이스와 연결성을 가진다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/220121/book.png&quot; style=&quot;width: 100%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;전체 페이지 대비 현재 내가 읽은 페이지를 계산해서 Progress를 나타낼 수 있는 Formula를 반영했다. 다른 Formula와 다르게 시각적으로 볼 수 있는 장치를 넣고 싶었다.&lt;/p&gt;

    &lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(not empty(prop(&quot;총 페이지&quot;)) and not empty(prop(&quot;현재 페이지&quot;)),
slice(&quot;❒❒❒❒❒❒❒❒❒❒&quot;, 0,floor(10 _ prop(&quot;현재 페이지&quot;) / prop(&quot;총 페이지&quot;))) + &quot; ■ &quot; +
slice(&quot;❒❒❒❒❒❒❒❒❒❒&quot;, 0, 10 - floor(10 _ prop(&quot;현재 페이지&quot;) / prop(&quot;총 페이지&quot;))) + &quot; &quot; +
format(floor(100 &lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt; prop(&quot;현재 페이지&quot;) / prop(&quot;총 페이지&quot;))) + &quot;%&quot;, &quot;&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;읽기 시작한 날과 다 읽은 날을 기록하여, 특정 카테고리의 책에 대한 완독 기간이 어떻게 되는지 계산해주는 Formula도 반영했다. 기간을 기록할 수 있으면, 그 기간동안 독서를 방해한, 독서를 촉진시킨 요소가 무엇인지 돌아볼 수 있겠다 싶었다.&lt;/p&gt;

    &lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;format(if(not empty(prop(&quot;다 읽은 날&quot;)), dateBetween(prop(&quot;다 읽은 날&quot;),
prop(&quot;읽기 시작한 날&quot;), &quot;days&quot;), toNumber(&quot;&quot;)) + 1) + &quot; 일&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;템플릿에는 없지만, 현재 내가 사용하고 있는 대시보드에는 Book Mark를 추가하는 템플릿 버튼을 넣어뒀다. 나는 독서를 하면서 기억하고 싶은 문장, 문단을 필사하는 습관이 있다. 메모장에만 남겨두기는 좀 그런 거 같고, 독후감을 적을때 북마크를 넣으면 간지날 것 같아서 만들어뒀다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/posts/220121/bookMark.png&quot; style=&quot;width: 60%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 72px&quot;&gt; &lt;/p&gt;

&lt;p&gt;대시보드 전체를 구상하고, 각각의 데이터베이스를 만들고, 메인 페이지에서 모아내는 작업은 하루를 꼬박 소모하게 만들었다. 휴직 기간 첫 주, 내 가슴을 뛰게 만든 첫번째 일이었다. 다시 일하러 가고 싶게 만들거나, 내 정신을 힘들게 만드는 그런 뜀박질이 아니었다.&lt;/p&gt;

&lt;p&gt;현재 내가 사용하고 있는 대시보드의 모습은 아래와 같다. 매일 아침에 눈을 뜨면 &lt;strong&gt;하루를 위한 계획을 짜고, 루틴을 체크하고, 책 내용을 기록하며 마지막으로 하루의 한 줄을 남기고 마무리&lt;/strong&gt;한다. 이 과정을 만든 것이 나에게는 너무 소중하고 지금의 상황을 극복하는데에 많은 도움을 주리라 믿고 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/220121/dashboard.png&quot; style=&quot;width: 100%; border: none; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; border-radius: 5px;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;내가 위에서 간략하게 기록한 각각의 데이터베이스가 포함된 노션 대시보드 템플릿을 만들었다. 이 글을 읽는 사람이 얼마나 될지는 모르겠지만 아래의 북마크(🥷)를 이용해서 편하게 개인 노션 계정에 복제해도 괜찮다.&lt;/p&gt;

&lt;div style=&quot;text-align: center; width: 40%; height 50px; background-color: #343a40; border: none; border-radius: 5px; box-shadow: rgb(24 25 31 / 15%) 0 6px 35px; cursor: pointer; padding: 5px&quot;&gt;
  &lt;a style=&quot;font-weight: bold; color: #fab005; text-decoration: none;  line-height: 50px&quot; href=&quot;https://bit.ly/hk_notion_templates&quot; target=&quot;_blank&quot;&gt;노션 대시보드 템플릿 훔쳐가기 🥷&lt;/a&gt;
&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 60px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="blog" /><category term="notion" /><summary type="html">2022년 시작부터 나는 휴직을 결심했다. 일과 내 삶이 너무 붙어있었다. 그 둘을 떨어뜨리지 않으면 둘 중 하나는 크게 다칠 것 같다는 판단이 강하게 내려졌다. 2021년 하반기 동료 리뷰에 담긴 주요 키워드도 역시 ‘분리’였다. 그래서 1월의 첫 주, 나는 휴직모드로 들어갔다.</summary></entry><entry><title type="html">잘가라 2021년</title><link href="https://hankyeolk.github.io/2021/12/30/review.html" rel="alternate" type="text/html" title="잘가라 2021년" /><published>2021-12-30T00:00:00+09:00</published><updated>2021-12-30T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/12/30/review</id><content type="html" xml:base="https://hankyeolk.github.io/2021/12/30/review.html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;로또 당첨되고 싶다!&lt;/em&gt;&lt;/strong&gt; 라고 끝맺음 했었던 정확하게 1년전의 글을 돌아봤다. 그때도 여전하게 코로나가 심했고 여전하게 추웠다.&lt;/p&gt;

&lt;p&gt;정확하게 1년이 지난 지금, 정말 새로웠던 2021년을 돌아보면서 다음의 1년을 준비해보려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;올해의-밈---오히려-좋아&quot;&gt;올해의 밈 - 오히려 좋아&lt;/h3&gt;

&lt;p&gt;올해는 정말 ‘오히려 좋아’라는 말을 얼마나 많이 했던지 세기도 힘들다. 스스로 업무에 의해서 많이 빡빡하다고 생각할때나, 감정적으로 지칠 시기가 되면 주문처럼 &lt;strong&gt;오히려 좋아&lt;/strong&gt;를 외웠다. 분위기가 무거워 질 것 같으면 ‘오히려 좋아’를 말하면서 회의 분위기를 바꾸기도 했다. 코로나 시국에 ‘오히려 좋다’는 사소한 말 하나가 널리 퍼지는게 어떻게 보면 너무 당연한 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;올해의-선택---장발&quot;&gt;올해의 선택 - 장발&lt;/h3&gt;

&lt;p&gt;나는 올해 4월부터 머리를 다듬으러 가지 않았다. 처음에는 회사에서 ‘도토리’라고 불릴 정도로 짧은 머리가 싫어서 ‘길러보자’라는 생각이 컸다. 그런데 생각외로 긴 머리가 자연스럽게 컬을 그리면서 퍽 어울려보이기 시작했다. 그래서 30살이 되기 전까지 한 번 맘잡고 길러보자는 선택을 했다. 이 선택은 정말 올해의 선택이었다. 머리 기른지 8개월이 다 되어가는 지금 뒷머리가 목의 끝부분까지 닿아있고 귀 뒤로 머리를 넘기는게 너무 자연스러워졌다. 물론 어울린다는 판단은 뚜렷한 나의 주관!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;올해의-성장---성장을-자극하는-조직에서의-성장&quot;&gt;올해의 성장 - 성장을 자극하는 조직에서의 성장&lt;/h3&gt;

&lt;p&gt;작년의 연말은 새롭게 다니게 된 코드스테이츠라고 하는 회사에서 가볍게 고개만 들고 다닐 정도였다. 그렇지만 지금은 간간히 ‘일잘러’라는 말을 들으면서 성장한 티를 많이 풍기고 있다. 그리고 여전히 코드스테이츠는 1차 분리를 성공적으로 이뤄낸 로켓처럼 괘도를 향해 달려가고 있다.&lt;/p&gt;

&lt;p&gt;회사 슬랙에 ‘#coz-worklog’라고 하는 회고를 남기는 채널이 있다. 입사 1주년을 돌아보면서 작성했던 그 회고에서 나는 ‘1년간 저에게 남은게 크루뿐이라고 해도 그 사실만으로 참 행복하네요.’라고 남겼다. 코드스테이츠 라고 하는 폭발적 성장을 촉구하는 조직에서 ‘버틸 수 있게’ 만드는 가장 큰 요소는 동료 크루들이다. (물론 지금은 개인 사정으로 잘 버티지 못하고 있지만)&lt;/p&gt;

&lt;p&gt;그래서 올해의 성장으로 코드스테이츠 자체와 그 속에서 성장한 나를 꼽았다. 이 글을 작성하기 직전에 내가 회사 노션 페이지에 작성했던 거의 대부분의 기획 문서를 돌아봤다. 주관적으로, 나는 올해도 성장했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;올해의-드라마---넷플릭스-지옥&quot;&gt;올해의 드라마 - 넷플릭스 지옥&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;유아인으로 시작된 드라마의 첫 점이 유아인으로 점철되지 않아서 너무 좋았던 드라마&lt;/li&gt;
  &lt;li&gt;한국적 정서를 명확하게 담았으면서도 억지로 짜내는 요소가 없었던 드라마&lt;/li&gt;
  &lt;li&gt;양익준 감독, 박정민 배우, 류경수 배우, 김신록 배우를 다시 알게 해준 너무 소중한 드라마&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;올해의-유튜브---피식대학&quot;&gt;올해의 유튜브 - 피식대학&lt;/h3&gt;

&lt;p&gt;한물 갔다 싶으면 어느새 찾아보게 되는 유튜버, ‘피식대학’. 처음에는 한사랑 산악회였다가 이호창 본부장에 빠졌었고, 05학번이즈백과 같은 콘텐츠는 억지로라도 웃게 만들었다. (용남이 인사를 강요하는 장면을 반복해서 돌려봤었다.) 회사 동료들과 점심시간에 정말 단골로 이야기 나누었던 유튜브 콘텐츠여서 더 좋았다. 내년에 피식대학이 보여줄 ‘next new’는 어떤 것일지 기대된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;올해의-여전히---코로나&quot;&gt;올해의 여전히 - 코로나&lt;/h3&gt;

&lt;p&gt;2022년 12월 30일에 작성하는 한 해 회고 블로그에는 ‘코로나’가 키워드로 등장하지 않았으면 좋겠다. 2021년은 200명대 코로나로 시작한 전사 재택 근무로 시작하여 매일 7000명 가량이 쏟아지는 정말 ‘with 코로나’까지, 온통 코로나였다. 이제 지겹다는 단어로도 표현이 잘 안된다. 박멸까지도 바라지 않으니까 마스크만 벗고 싶다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/211231/new-year.png&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="blog" /><category term="review" /><summary type="html">로또 당첨되고 싶다! 라고 끝맺음 했었던 정확하게 1년전의 글을 돌아봤다. 그때도 여전하게 코로나가 심했고 여전하게 추웠다.</summary></entry><entry><title type="html">SSH로 GitHub 연결하기</title><link href="https://hankyeolk.github.io/2021/08/15/githubSSH.html" rel="alternate" type="text/html" title="SSH로 GitHub 연결하기" /><published>2021-08-15T00:00:00+09:00</published><updated>2021-08-15T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/08/15/githubSSH</id><content type="html" xml:base="https://hankyeolk.github.io/2021/08/15/githubSSH.html">&lt;p&gt;어느때와 동일하게 로컬에서 업데이트한 코드를 내 원격 GitHub Repository에 push 하려고 할 때, 갑자기 github의 인증 관련 에러가 터미널을 덮었다. 에러의 요지는 이렇다. ‘2021년 8월 13일부로 GitHub 계정의 비밀번호로 원격의 git 동작을 제어하는 권한을 제한한다’는 것이다. 작년 7월 &lt;a href=&quot;https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/&quot;&gt;GitHub Blog&lt;/a&gt;에 글로 미리 공지를 했다는데.. CLI를 통해서 https 주소로 GitHub 원격 저장소에 접근하는 나는 당황하지 않을 수 없었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210815/1.png&quot; style=&quot;width: 100%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;근데, 깃헙 블로그에 &lt;em&gt;‘the following customers remain unaffected by this change’&lt;/em&gt;라는 예외 조항이 있었다. 그 중 하나가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH-based&lt;/code&gt; 인증을 한 사람은 괜찮다는 것이었다. 서로 다른 컴퓨터간의 통신에서 ‘보안성’을 높여주는 SSH 프로토콜 방식 기반의 코드 관리가 가능하다고는 알고 있었다. 다만, https url 형식이 너무 편해서 시도할 생각을 하지 않고 있었다. 경우가 경우인 만큼, 이번에 SSH 프로토콜 방식으로 변경하였다. 그 경험을 공유한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 45px&quot;&gt; &lt;/p&gt;

&lt;h4 id=&quot;ssh&quot;&gt;SSH&lt;/h4&gt;

&lt;p&gt;Secure SHell의 줄임 표현인 SSH는 원격 컴퓨터와의 통신을 위한 프로토콜이다. Secure하다는 것이 강조되기 때문에 ‘보안’에 집중한 프로토콜임을 알 수 있다. SSH는 기본적으로 2가지의 키로 암호화, 복호화 과정을 거쳐서 통신한다.&lt;/p&gt;

&lt;p&gt;SSH에서 2가지 키가 사용된다고 했는데, 그것은 각각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public key (공개키)&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private key (비밀키)&lt;/code&gt;다. SSH 키를 생성하면 공개키와 비밀키가 동시에 생성된다. 비밀키는 내 로컬 컴퓨터의 특정 장소에, ‘옵셔널하게 (유저에 의향에 의해) 비밀키 확인을 위한 비밀번호 설정을 할 수 있다.’, 저장된다. 공개키는 리모트, 즉 통신하려고 하는 원격 저장소(나의 경우는 GitHub)에 부여한다.&lt;/p&gt;

&lt;p&gt;원격 저장소와 통신을 하기 위해서, 요청을 보내는 내 컴퓨터(로컬 환경)에서는 원격 컴퓨터의 공개키와 내 비밀키를 맞추어보고 정확한 ‘한 쌍’인지를 파악한다. 서로가 한 쌍의 키라는 것이 증명되면 두 컴퓨터 사이에 ‘암호화된’ 채널이 형성되고 서로의 키로 암호화 복호화하는 과정으로 데이터를 주고 받을 수 있다.&lt;/p&gt;

&lt;p&gt;GitHub의 원격 저장소의 코드를 복제하고(git clone), 내가 로컬환경에서 작업한 코드를 GitHub 원격 저장소에 올리는(git push) 작업 역시 로컬-원격 저장소간의 통신이다. 그렇기 때문에 ‘보안’이 강화된 SSH 방식을 사용하면 더욱 안전하게 코드 버전을 관리할 수 있게된다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 45px&quot;&gt; &lt;/p&gt;

&lt;h4 id=&quot;ssh-방식으로-github-연결하기&quot;&gt;SSH 방식으로 GitHub 연결하기&lt;/h4&gt;

&lt;p&gt;SSH를 이용해서 GitHub과 코드를 주고 받기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH 키&lt;/code&gt;를 가장 먼저 생성해야 한다. 나는 맥(macOS)을 사용하고 있기 때무네 그것을 기반으로 작성하겠다. 사실 다른 운영체제들도 방법은 비슷하다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 로컬 경로에서 ~/.ssh 를 찾아들어간다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/.ssh
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;p&gt;해당 경로에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt; 커맨드로 존재하는 디렉토리 또는 파일을 살핀다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_dsa&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_rsa.pub&lt;/code&gt;와 같은 파일이 있을 수 있다. 만약 이 파일이 없다면 키 생성기로 키를 생성해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210815/4.png&quot; style=&quot;width: 50%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;p&gt;파일이 이미 생성되어 있다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat&lt;/code&gt; 커맨드로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_rsa.pub&lt;/code&gt; 파일을 한 번 읽어보면 좋다. ssh-rsa~ 로 시작하는 아주 긴 암호화된 키가 보일 것이다. 확장자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pub&lt;/code&gt;인 것을 보면 이미 눈치챘겠지만, 해당 파일의 키가 공개키다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 45px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1-1. ssh-keygen으로 키 생성하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;macOS에는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-keygen&lt;/code&gt;이라고 하는 프로그램이 있다. ~/.ssh 경로에 아무런 파일이 없다면 루트 경로에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ ssh-keygen&lt;/code&gt; 이라는 커맨드를 입력하여 SSH를 위한 키를 생성하면 된다.&lt;/p&gt;

&lt;p&gt;그 과정에서 아마 키를 조회하기 위한 비밀번호 설저을 물어본다. 나 같은 경우에는 비밀번호 입력 자체를 번거로워하지 않기 때문에 꼭 설정했다. 비밀번호를 생성했다면 다시 ~/.ssh 경로에 들어가서 파일이 잘 생성되었는지 확인해보자.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 45px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 공개키 GitHub에 등록하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 원격 저장소인 GitHub의 내 계정에 내 로컬 컴퓨터에서 생성한 SSH 공개키를 등록해준다. 등록은 GitHub 👉 (우측 상단의 유저 아이콘) Settings 👉 SSH and GPG Keys 👉 (초록색) New SSH Key 버튼 클릭으로 등록하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210815/5.png&quot; style=&quot;width: 100%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 24px&quot;&gt; &lt;/p&gt;

&lt;p&gt;등록을 완료했다면 로컬 터미널에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ ssh -T git@github.com&lt;/code&gt; 명령어로 SSH 방식의 인증이 잘 되었는지 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210815/2.png&quot; style=&quot;width: 100%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 45px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. SSH 방식으로 GitHub 사용하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 SSH 기반으로 GitHub 연결을 사용할 준비는 다 마쳤다. 기존과 동일하게 로컬 터미널에서 커맨드라인으로 접근할 수 있다. 다만, SSH 방식의 URL은 https URL과 다르기 때문에 그 부분만 잘 신경쓰면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3-1. Git Clone&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[] 안에는 각자의 GitHub 계정, Repository 이름을 작성하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone git@github.com:[username]/[repository name].git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3-2. 기존 레포지토리 SSH 방식 주소로 변경하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기존에 https URL 로 등록된 레포지토리밖에 없었던 나는 아래의 커맨드라인으로 통신하고자 하는 원격 저장소의 URL을 다 SSH 방식으로 변경해주었다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git remote set-url &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;origin name] git@github.com:[username]/[repository name].git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 45px&quot;&gt; &lt;/p&gt;

&lt;p&gt;SSH 방식으로 GitHub과 연결하는 것에 대한 간략한 경험을 작성했다. 혹시 나처럼 ‘SSH 방식으로 변경해야 하는데..’ 라던지, ‘아 깃헙 커맨드라인 이제 못쓰나?’ 라고 살짝 혼란을 겪은 분이라면 정말 등록 과정이 간단하니 빠르게 시도해보는 것을 추천한다!&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 45px&quot;&gt; &lt;/p&gt;

&lt;p&gt;참고한 레퍼런스&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/ko/v2/Git-%EC%84%9C%EB%B2%84-SSH-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0&quot;&gt;Git SSH 공개키 만들기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent&quot;&gt;Git SSH Agent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 45px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="git" /><summary type="html">어느때와 동일하게 로컬에서 업데이트한 코드를 내 원격 GitHub Repository에 push 하려고 할 때, 갑자기 github의 인증 관련 에러가 터미널을 덮었다. 에러의 요지는 이렇다. ‘2021년 8월 13일부로 GitHub 계정의 비밀번호로 원격의 git 동작을 제어하는 권한을 제한한다’는 것이다. 작년 7월 GitHub Blog에 글로 미리 공지를 했다는데.. CLI를 통해서 https 주소로 GitHub 원격 저장소에 접근하는 나는 당황하지 않을 수 없었다.</summary></entry><entry><title type="html">Create-React-App 없이 리액트 프로젝트 보일러 플레이스 세팅하기</title><link href="https://hankyeolk.github.io/2021/08/08/withoutCRA.html" rel="alternate" type="text/html" title="Create-React-App 없이 리액트 프로젝트 보일러 플레이스 세팅하기" /><published>2021-08-08T00:00:00+09:00</published><updated>2021-08-08T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/08/08/withoutCRA</id><content type="html" xml:base="https://hankyeolk.github.io/2021/08/08/withoutCRA.html">&lt;h1 id=&quot;create-react-app-없이-리액트-프로젝트-환경-구축하기&quot;&gt;Create-React-App 없이 리액트 프로젝트 환경 구축하기&lt;/h1&gt;

&lt;h3 id=&quot;직접-환경을-구축해보는-것에-대해서&quot;&gt;직접 환경을 구축해보는 것에 대해서&lt;/h3&gt;

&lt;p&gt;CRA는 분명히 빠른 리액트 프로젝트를 시작하게 만들어주는 좋은 도구임에는 틀림없다. CRA를 통해서 프로젝트 자체를 빌드 할 수 있다. CRA가 나쁘다는 이야기를 하려고 이 글을 적는 것이 아님을 시작에 강조한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그럼에도 내가 이 기록을 남기는 이유는 너무 맹목적인 CRA를 남발하지 않기 위함이다. 웹팩으로 프로젝트를 구축해보면서 어떤 플러그인, 로더를 적소에 적용해야 하는지 배우기 위함이다. 바벨을 통해서 어떻게 언어의 문법간 호환성을 지켜야 하는지를 공부하기 위함이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그래도 나는 여전히 CRA가 너무 편하고 좋다. 필요하다면 CRA를 적극적으로 쓰는 것도 좋은 것 같다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;시작은-필요한-모듈-설치로부터&quot;&gt;시작은 필요한 모듈 설치로부터&lt;/h3&gt;

&lt;p&gt;나는 yarn으로 노드 모듈을 설치하는 것을 좋아한다. 조금 더 빠르다는 느낌도 있고, 터미널에서 모듈을 받았을때 나오는 문구도 조금 더 세련된 것 같아서 그렇다. 그래서 기록의 대부분은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add&lt;/code&gt;로 구성될 것 같다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;우선, 프로젝트를 시작할 폴더를 하나 만들고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn init -y&lt;/code&gt;로 노드 프로젝트임을 드러낸다. 그리고 리액트와 관련된 모듈을 설치한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add react react-dom&lt;/code&gt; react-dom은 react와 dom을 직접적으로 연결해주는 모듈이다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Babel &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그 다음, 자바스크립트의 서로다른 문법간의 오류를 하나로 통합해줄 바벨의 모듈들을 설치한다. JSX와 ES6 이상의 문법을 다른 브라우저가 이해할 수 있도록 ES5 문법으로 변환해준다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add @babel/core @babel/preset-react @babel/preset-env&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;바벨의 모듈은 앞에 ‘@’ 마크가 붙는 특징이 있다. 바벨에 대한 자세한 설명은 이전 TIL에 개발환경 구축의 내용을 정리한 것이 있다. 그 부분을 함께 참고하자. &lt;a href=&quot;https://github.com/hankyeolk/TIL/blob/main/Dev_Env/babel.md&quot;&gt;개발환경 이해하기 - Babel&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@babel/preset-react : 리액트의 JSX 문법을 자바스크립트 코드로 변환해준다.&lt;/li&gt;
  &lt;li&gt;@babel/preset-env : ES6 이상의 자바스크립트 문법을 다른 브라우져에서도 호환 가능하도록 ES5로 변환해주는 프리셋이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Webpack and Loader &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로젝트 환경 구축의 핵심인 웹팩과 관련 모듈을 설치한다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add -D webpack webpack-cli webpack-dev-server babel-loader css-loader style-loader&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack-dev-server&lt;/code&gt; : 이름에서도 알 수 있듯이 개발 모드에 필요한 서버를 구동해준다. 컴퓨터의 메모리를 빌려 웹팩을 구동하고 임0시 서버를 띄우는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;css-loader, style-loader&lt;/code&gt; : css 문법을 자바스크립트로 변환해주는 역할을 한다. / css-loader가 변환한 파일을 index.html의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그에 넣는 역할을 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 다음, 번들링 파일에 적용할 플러그인을 설치한다. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn add -D html-webpack-plugin clean-webpack-plugin&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html-webpack-plugin&lt;/code&gt;: html파일에 번들링된 리액트 코드를 삽입해준다. 그리고 dist 폴더에 번들링된 파일을 옮겨주는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clean-webpack-plugin&lt;/code&gt; : 번들링이 완료될 때마다 이전의 번들링 결과를 제거해주는 역할을 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;이제-바벨-웹팩-설정-파일을-만들면서-프로젝트-환경을-완성해보자&quot;&gt;이제 바벨, 웹팩 설정 파일을 만들면서 프로젝트 환경을 완성해보자.&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;babel.config.js &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;바벨 설정 파일에는 프리셋을 잘 적용해주는 것이 중요하다. 프리셋은 바벨의 역할들을 모아둔 도구 상자라고 생각하면 편하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt; 이름으로 파일 이름을 지을 수도 있다. 이렇게 사용할 프리셋을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;presets&lt;/code&gt; 항목에 배열로 넣어주면된다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// babel.config.js&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;presets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;@babel/preset-env&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;@babel/preset-react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;webpack.config.js &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가장 중요한 설정은 웹팩 설정이다. 실질적으로 웹팩으로 어떻게 번들링을 하는지에 따라서 프로젝트의 결과가 완전히 달라질 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webpack.config.js&lt;/code&gt;파일을 구축하면서 꼼꼼하게 알아보자.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// webpack.config.js&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HtmlWebpackPlugin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;html-webpack-plugin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CleanWebpackPlugin&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;clean-webpack-plugin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dotenv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;dotenv&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설정에서 사용하는 개발 모드/프로덕션 모드를 구분하고 개발 서버의 포트 변호를 환경변수로 관리하기 위해서 dotenv를 설치해서 사용했다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./src/index.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__dirname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/dist&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;bundle.[hash].js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;publicPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// path.resove 형태로 사용할 수도 있다.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 그러면 node의 기본 모듈 'path'를 불러와야 한다.&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;extensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;.jsx&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;번들링이 시작될 곳은 리액트 프로젝트에서 보통 리액트 돔에 랜더링을 거는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;index.js&lt;/code&gt;로 정했다. 엔트리 포인트는 개발자가 알아서 정해주면 된다. 번들링 결과는 보통 dist 폴더에 해쉬가 된채로 저장된다. 번들링을 할 파일은 ‘.js, .jsx’의 확장자를 가진 파일이다. 나는 보통 자바스크립트로 리액트 프로젝트를 할 경우 컴포넌트 파일명을 ‘.jsx’ 확장자로 짓는다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\.(&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;js|jsx&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;$/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;exclude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/node_modules/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;babel-loader&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;css$/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;style-loader&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;css-loader&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로더는 rules 항목에서 지정해줄 수 있다. 중점적으로 신경써야 하는 것은 로더의 순서다. 웹팩은 등록한 로더의 배열에서 뒤의 요소부터 번들링에 반영한다. css를 자바스크립트로 변환한 다음 style 태그에 넣어주어야 하기 때문에 위의 순서를 가진다. 또한 node_modules 폴더의 모든 모듈들을 다 번들링 할 필요 없기 때문에 이걸 제외해주는 것도 중요하다.&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CleanWebpackPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;HtmlWebpackPlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;public/index.html&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;DefinePlugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;devServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;historyApiFallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;hot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;플러그인은 각 생성자 함수로 인스턴스를 만들어주는 방식으로 적용한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefinePlugin&lt;/code&gt;의 경우 웹팩의 기본 플러그인이라서 webpack으로 부터 가지고 왔다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.env&lt;/code&gt; 파일에 등록한 개발 모드와 포트 넘버를 등록해서 사용할 수 있게 해준다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;devServer&lt;/code&gt;는 개발 서버를 열어주는 용도다. ‘hot’ 키워드를 true 값으로 설정해서 변화가 발생하면 바로 번들링이 발동되고 서버에 반영될 수 있도록 설정해주면 우리가 react 프로젝트에서 늘 봤던 ‘yarn start’를 만들어준다. 물론 스크립트에 등록을 해야한다. &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;packagejson-파일에-스크립트-등록하고-리액트-개발-시작하기&quot;&gt;package.json 파일에 스크립트 등록하고 리액트 개발 시작하기&lt;/h3&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;webpack serve --progress --mode development&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;build&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;webpack&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“start” 명령어에 ‘webpack-dev-server’를 등록해서 리액트 스크립트가 동작할 수 있도록 설정한다. ‘hot’ 키워드가 등록되어 있기때문에 프로젝트는 리액트의 사소한 변화를 반영할 수 있다. “build” 명령어를 동작하면 dist 폴더에 번들링된 파일들이 생성될 것이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 우리에게 남은 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public/index.html&lt;/code&gt;을 생성하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src/index.js&lt;/code&gt;에 가벼운 리액트 코드를 작성하는 것이다. 물론 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn start&lt;/code&gt; 명령어로 웹팩을 돌리고 3000번 포트(.env에 설정해준)에서 결과를 확인하는 것은 덤이다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- public/index.html --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width=divice-width, initial-scale=1.0&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;http-equiv=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ie=edge&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;react-twittler&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// index.js&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ReactDom&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;react-dom&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hankyeol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;ReactDom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/wSzh8iSdYUQ&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;blockquote&gt;
  &lt;p&gt;부끄럽지만.. 회사에서 해당 내용으로 기술 발표 영상을 찍었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="react" /><category term="webpack" /><category term="babel" /><summary type="html">Create-React-App 없이 리액트 프로젝트 환경 구축하기</summary></entry><entry><title type="html">[시리즈 - 코어 자바스크립트] 자바스크립트 프로토타입</title><link href="https://hankyeolk.github.io/2021/06/30/coreJavascript3.html" rel="alternate" type="text/html" title="[시리즈 - 코어 자바스크립트] 자바스크립트 프로토타입" /><published>2021-06-30T00:00:00+09:00</published><updated>2021-06-30T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/06/30/coreJavascript3</id><content type="html" xml:base="https://hankyeolk.github.io/2021/06/30/coreJavascript3.html">&lt;blockquote&gt;
  &lt;p&gt;이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;자바스크립트-프로토타입&quot;&gt;자바스크립트 프로토타입&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바스크립트가 프로토타입 기반의 언어라는 점은 많이 들어서 알고 있을 것이다. 클래스 기반의 언어에 있는 상속과는 다르게 특정한 객체 하나를 원형(prototype)으로 삼고 이를 복제하는 방식으로 상속의 흉내낸다. 프로토타입의 개념을 한 번 이해하는 것이 어렵지만 이번에 해내보자.&lt;/p&gt;

&lt;h3 id=&quot;기본&quot;&gt;기본&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/core-javascript/prototype.png&quot; style=&quot;width: 80%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 이미지의 흐름을 정리하면 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;어떤 생성자 함수를 new 키워드와 함께 호출하면 생성자에서 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성된다.&lt;/li&gt;
  &lt;li&gt;인스턴스가 생성될때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;라고 하는 프로퍼티가 자동으로 부여된다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티는 Constructor에 있는 prototype 이라고 하는 프로퍼티를 참조한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prototype&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;는 모두 객체다. prototype 객체에는 인스턴스가 사용할 메서드를 저장한다. 이를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;를 통해 인스턴스가 이 메서드들에 접근할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Dobby&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//undefined&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dobby.__proto__.getName()&lt;/code&gt;을 찍어보면 undefined가 나오는 것을 알 수 있다. 함수를 메서드로 호출하면 ‘.’ 앞의 객체가 바로 this가 된다. 그래서 getName 메서드가 묶인 this는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dobby.__proto__&lt;/code&gt; 객체가 된다. 이 객체 내부에는 ‘name’이라는 프로퍼티가 없기 때문에 정의되지 않은 식별자를 찾을때 뱉는 undefined가 나온 것이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Dobby&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 'Dobby'&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;dobby&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 'Dobby'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dobby.getName()&lt;/code&gt; 처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;를 제외하면 this 걱정없이 메서드를 사용할 수 있다. 그 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;가 생략 가능한 프로퍼티이기 때문이다. 자바스크립트의 단순한 문법적인 측면이기 때문에 생략 가능하다는 정도로만 이해하고 넘어가자.&lt;/p&gt;

&lt;p&gt;정리하면, ‘new Constructor() 형태로 인스턴스를 생성하면 생략 가능한 프로퍼티 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;가 생성되고 이것은 Constructor의 prototype 객체를 참조한다.’&lt;/p&gt;

&lt;p&gt;Array라고 하는 생성자를 직접 콘솔에 찍어보면 prototype과 기본 내장 메서드를 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;prototype-객체-내부의-constructor-프로퍼티&quot;&gt;prototype 객체 내부의 constructor 프로퍼티&lt;/h3&gt;

&lt;p&gt;생성자 함수의 prototype 객체에는 constructor라고 하는 자기 자신을 참조하는 프로퍼티가 있다. 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 객체에도 존재한다. 이것은 인스턴스와의 관계를 나타내기 위해 필요한 정보인데, 인스턴스의 원형이 무엇인지를 알 수 있는 수단 역할을 한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [3, 4]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로토타입-체인&quot;&gt;프로토타입 체인&lt;/h3&gt;

&lt;h4 id=&quot;메서드-오버라이드&quot;&gt;메서드 오버라이드&lt;/h4&gt;

&lt;p&gt;prototype 객체를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;를 생략할 수 있기 때문에, 인스턴스는 prototype에 정의된 프로퍼티나 메서드를 자신의 것처럼 사용할 수 있는 것처럼 보인다. 아래의 예시를 한 번 보자.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;이지은&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;IU는 &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;이다.&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 'IU는 이지은이다.'&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__proto__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// '이지은'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IU 인스턴스에 있는 메서드가 호출된다. Person prototype 객체에 등록된 getName 메서드와 동일한 함 수 명이기 때문에 원본이 있는 그 상태에서 다른 대상을 얹은 것이다.&lt;/p&gt;

&lt;p&gt;오버라이딩 되지 않고, prototype에 등록된 메서드가 동자가헤 하려면, IU 인스턴스에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;에다가 IU 인스턴스를 바라볼 수 있게 등록하면 된다. call, apply 메서드로 바인딩을 해주면 된다. 원본 메서드를 사용하기 위해서 우회를 해야한다는 점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로토타입-체인-1&quot;&gt;프로토타입 체인&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.dir([1, 2])&lt;/code&gt;를 찍어보면 우리에게 익숙한 pop, push와 같은 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티 안에 있다는 것을 볼 수 있다. constructor는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f Array()&lt;/code&gt;로 배열 생성자 함수를 가르키고 있는 것으로 보인다. 그런데 &lt;strong&gt;proto&lt;/strong&gt;안에 또 다른 &lt;strong&gt;proto&lt;/strong&gt;가 있는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;그것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.dir({a: 1})&lt;/code&gt;을 찍어봤을 때의 &lt;strong&gt;proto&lt;/strong&gt;와 동일하다는 것을 알 수 있다. 이것은 모든 객체의 &lt;strong&gt;proto&lt;/strong&gt;에 Object.prototype이 연결되기 때문이다. 아래의 그림처럼 연결되어 있는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/core-javascript/prototype2.png&quot; style=&quot;width: 80%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt;는 생략이 가능한 프로퍼티이기 때문에 배열은 Object.prototype의 내부 메서드를 자신의 것처럼 사용할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;array(.__proto__)(.__proto__).hasOwnProperty();&lt;/code&gt; 이렇게 말이다.&lt;/p&gt;

&lt;p&gt;이런 것처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티 내부에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 프로퍼티가 연쇄적으로 이어진 형태를 프로토타입 체인이라고 한다. 이 체인을 따라가며 검색하는 과정을 프로토타입 체이닝이라고 한다.&lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="js" /><category term="series" /><category term="book" /><summary type="html">이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.</summary></entry><entry><title type="html">[시리즈 - 코어 자바스크립트] 자바스크립트 실행 컨텍스트</title><link href="https://hankyeolk.github.io/2021/06/19/coreJavascript2.html" rel="alternate" type="text/html" title="[시리즈 - 코어 자바스크립트] 자바스크립트 실행 컨텍스트" /><published>2021-06-19T00:00:00+09:00</published><updated>2021-06-19T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/06/19/coreJavascript2</id><content type="html" xml:base="https://hankyeolk.github.io/2021/06/19/coreJavascript2.html">&lt;blockquote&gt;
  &lt;p&gt;이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;자바스크립트-실행-컨텍스트&quot;&gt;자바스크립트 실행 컨텍스트&lt;/h3&gt;

&lt;p&gt;실행 컨텍스트는 실행할 코드에 제공할 환경 정보를 모아놓은 객체다. 어떤 실행 컨텍스트가 활성화되는 시점에 어떤 변수가 끌어올려지고, 외부 환경 정보를 설정하고, this 값을 설정하는 등의 동작을 수행한다.&lt;/p&gt;

&lt;p&gt;동일 환경에 있는 코드를 실행할 때 필요한 환경 정보를 모두 모아 컨텍스트로 구성하고, 이를 콜 스택에 쌓아올린다. 여기서 스택은 자료구조의 ‘그’ 스택이 맞다. 가장 위에 쌓은 컨택스트와 관련있는 코드를 실행하는 식으로 전체 코드의 환경과 순서를 정한다.&lt;/p&gt;

&lt;p&gt;하나의 동일한 환경, 하나의 실행 컨텍스트를 구성할 수 있는 방법은 다양하게 있다. 전역공간에서의 작업, eval() 함수의 활용, 가장 흔한 방법은 함수를 &lt;strong&gt;실행하는 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-컨텍스트-스택의-기본-동작&quot;&gt;실행 컨텍스트 스택의 기본 동작&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// -- (1)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -- (2)&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -- (3)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 (1)의 환경은 전역 컨텍스트다. 코드가 읽히는 순간 가장 먼저 콜 스택에 담긴다. 전역 컨텍스트는 별도의 실행 명령 없이도 브라우저에서 자동으로 실행하는 컨텍스트다. 말 그대로 파일이 브라우저에서 열리는 순간 전역이 펼쳐지는 것이다.&lt;/p&gt;

&lt;p&gt;전역적으로 코드들을 담다가, (3)에서 함수 호출을 만나면 outer 함수에 대한 환경 정보들을 컨텍스트로 생성하여 콜 스택에 담는다. outer() 함수의 실행 컨텍스트를 콜 스택에 담는 것이다. 이제 전역에서 시행하는 것을 멈추고 outer 함수 내부의 코드들을 순차적으로 실행시킨다.&lt;/p&gt;

&lt;p&gt;outer() 함수 내부에서 inner() 함수를 호출하는 (2)번 환경이 있기 때문에 콜 스택은 해당 inner 함수의 환경을 실행 컨텍스트로 담는다. 스택의 특성상 가장 뒤에 들어온 요소를 가장 먼저 처리해야하기 때문에 inner가 처리되고, outer, 다시 전역 순서로 진행한다.&lt;/p&gt;

&lt;p&gt;하나의 실행 컨텍스트가 콜 스택의 가장 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점이다. 새로운 스택으로 특정 컨텍스트가 활성화되면 해당 코드를 실행하는 것에 필요한 환경 정보를 수집한 객체가 실행 컨텍스트에 저장되는 방식이 자바스크립트의 동작 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-컨텍스트-객체-엘리먼트&quot;&gt;실행 컨텍스트 객체 엘리먼트&lt;/h3&gt;

&lt;p&gt;실행 컨텍스트 객체는 자바스크립트 엔진이 코드를 돌리는 목적으로 생성되기 때문에 우리가 코드를 통해서 직접 확인하기는 힘들다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Variable Environment (변수 환경)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;현재 컨택스트가 가지고 있는 식별자에 대한 정보, 외부 환경 정보, 선언 시점의 Lexical 환경의 스냅샷을 가지는 환경이다. 해당 컨텍스트가 최초로 실행될 때의 스냅샷을 유지한다. 이 스냅샷을 그대로 복사해서 Lexical 환경을 만든다. 실핵 컨텍스트의 템플릿을 만드는 격이라고 생각하면 편하겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lexical Environment (사전적 환경)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;처음 선언될 때에는 Variable 환경과 동일하지만 변경사항이 생기면 실시간으로 반영되는 환경이다. “현재 컨텍스트에는 어떤 어떤 식별자들이 있고, 외부 환경에 대한 정보는 특정 어떤 주소를 참조하도록 되어있다.” 이런 형식으로 사전처럼 정의된 환경이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;environmentRecord&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;environmentRecord에는 현재 컨텍스트와 관련된 코드 식별자 정보가 저장된다. 함수의 매개변수 이름, 함수 그 자체, 선언된 변수가 컨텍스트의 식별자가 된다. 코드 위에서 아래로 훑으며 순서대로 수집한다.&lt;/p&gt;

&lt;p&gt;수집된 식별자들은 호이스팅을 통해서, 자바스크립트 엔진이 실질적으로 식별자들을 실행의 가장 상단으로 끌어올리지는 않지만, 코드 해석의 최상단으로 끌어올려진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;호이스팅-hoisting--hoist--ing-규칙&quot;&gt;호이스팅 (hoisting = hoist + ing) 규칙&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;특정 실행 컨텍스트에 대해서 변수는 선언만 끌어올린다. 할당은 끌어올리지 않는다. 매개변수로 들어오는 값도 동일하다.&lt;/li&gt;
  &lt;li&gt;함수에 대한 선언은 함수 전체를 끌어올린다. 동일 변수명으로 함수를 선언하면 해당 변수명의 주소값에 함수만 담겨 끌어올려진다고 생각하자. 다만, 표현식으로 작성된 함수는 끌어올려지지 않는다. 할당의 개념이기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;함수 선언과 표현식&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;함수를 정의하는 방법은 아래의 3가지 방식을 따른다. 선언식의 경우 보통 function 키워드로 선언하는 부분만 존재하고 별도의 할당 과정이 없다. 함수 선언식의 경우에는 반드시 함수명이 정의되어야 한다.&lt;/p&gt;

&lt;p&gt;이와 반대로 함수 표현식은 정의한 함수를 별도 변수에 할당하는 과정 자체를 의미한다. 표현식으로 작성된 함수는 별도의 이름이 꼭 존재하지는 않아도 된다. 익명함수라고도 한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 선언식&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 표현식 -&amp;gt; function 키워드&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 이름이 있는 함수 표현식 -&amp;gt; 외부에서 해당 함수명으로 호출 불가&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -&amp;gt; error&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 표현식 -&amp;gt; arrow function&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;스코프&quot;&gt;스코프&lt;/h3&gt;

&lt;p&gt;스코프는 식별자, 변수가 접근 가능한 유효범위다. ES6부터 자바스크립트는 함수, 블록에 대한 스코프가 구분되었다. 식별자의 유효범위가 안에서부터 바깥으로 순서대로 검색하는 체인을 ‘스코프 체인’이라고 한다. 자바스크립트에서 스코프는 중괄호로 구분한다. 또한 함수의 내부에 식별자가 있는지 외부에 있는지도 스코프를 따지는 것에 큰 영향을 준다.&lt;/p&gt;

&lt;p&gt;스코프의 규칙을 정리하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내부에 있는 스코프에서 외부의 스코프로의 접근은 가능하다. 즉, 내부 스코프에서 외부에 정의된 변수를 조회할 수 있고, 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;외부 스코프에서는 내부에 정의된 식별자를 조회할 수 없다. 이것을 통해서 우리는 변수의 은닉화를 할 수 있다.&lt;/li&gt;
  &lt;li&gt;스코프는 중첩이 가능하다. 중첩된 가장 외부의 스코프를 전역(global), 그것이 아닌 스코프는 모두 지역(local) 스코프다.&lt;/li&gt;
  &lt;li&gt;지역 스코프 내에서 선언된 식별자, 변수가 Lexical 환경에서 조회되기 때문에 우선순위를 가진다. Lexical한 환경에서 선언된 식별자가 없다면 그 다음 스코프를 뒤지고 또 다음 스코프를 뒤지는 형식으로 가는 것이다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>hankyeolk</name></author><category term="js" /><category term="series" /><category term="book" /><summary type="html">이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.</summary></entry><entry><title type="html">[시리즈 - 코어 자바스크립트] 자바스크립트 데이터 타입</title><link href="https://hankyeolk.github.io/2021/06/12/coreJavascript1.html" rel="alternate" type="text/html" title="[시리즈 - 코어 자바스크립트] 자바스크립트 데이터 타입" /><published>2021-06-12T00:00:00+09:00</published><updated>2021-06-12T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/06/12/coreJavascript1</id><content type="html" xml:base="https://hankyeolk.github.io/2021/06/12/coreJavascript1.html">&lt;blockquote&gt;
  &lt;p&gt;이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;자바스크립트의-데이터-타입&quot;&gt;자바스크립트의 데이터 타입&lt;/h3&gt;

&lt;p&gt;자바스크립트의 데이터 타입은 크게 2가지가 있다. 기본형(primitive)과 참조형(reference) 타입이다. 타입을 구분하는 기준에 대해서 명확하게 아는 것이 중요하다. 두 타입 모두 무언가를 &lt;strong&gt;‘복제’&lt;/strong&gt;하긴 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;기본형 타입은 값이 담긴 주소의 값을 바로 복제한다. 그리고 기본형은 불변성(immutability)을 띈다. 기본형에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Number, String, Boolean, null, undefined, Symbol&lt;/code&gt;이 있다. Symbol 타입은 ES6 이후에 등장했다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참조형 타입은 값이 담긴 주소의 값들로 이루어진 묶음의 주소 값을 복제한다. 참조형에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object&lt;/code&gt;가 있고 객체 아래에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array, Function, Date, RegExp, Map, Set&lt;/code&gt;이 속한다. 객체 하위 분류에 해당한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;식별자와-변수&quot;&gt;식별자와 변수&lt;/h3&gt;

&lt;p&gt;모든 데이터는 바이트(8비트) 단위의 식별자를 통해서 서로 구분하고 연결할 수 있다. &lt;strong&gt;식별자는 우리가 잘 아는 ‘변수명’이다. 더 정확하게는 메모리 주솟값&lt;/strong&gt;이다. 변수는 말 그대로 변할 수 있는 값이고 숫자형, 문자열, 객체, 배열 등 모든 데이터 형식을 의미한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;하나의 변수명(식별자)을 선언하면 메모리에 해당 변수명을 위한 공간이 생긴다. 변수명은 그 메모리를 고유하게 인식하게 만드는 식별자인 것이다. 변수명에는 할당된 값을 직접적으로 저장하는 것이 아니라 값이 할당된 메모리 주소를 기록하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;불변값-가변값-복사&quot;&gt;불변값, 가변값, 복사&lt;/h3&gt;

&lt;p&gt;위에서 자바스크립트의 기본형 데이터 타입은 값이 변하지 않는 불변성을 띈다고 말했다. 변수에 새로운 값을 할당하려고 하면 메모리에 새로운 데이터 공간을 만들어서 저장하고 그 데이터 공간의 주소를 변수명에 변경해준다. 완전히 새로운 값의 주소를 반영해주는 것이다. 그래서 &lt;strong&gt;‘불변’한다&lt;/strong&gt;고 표현한다. 한 번 만들어진 기본형 데이터 값은 새로 만드는 동작을 통해서만 변경을 진행한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참조형 데이터는 무언가 ‘가변값’일 것 같다. 참조형 데이터를 컴퓨터가 어떻게 처리하는지 아래의 아주 간단한 코드를 뜯어보면서 알아보자. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;특정 주소에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj&lt;/code&gt;라고 하는 식별자 주소를 만든다. 이 변수명에 담길 프로퍼티가 여러개라는 것을 인식하게 된다.&lt;/li&gt;
  &lt;li&gt;다양한 프로퍼티의 변수를 인식할 새로운 변수 영역 주소를 새롭게 생성한다. 여기서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;에 대한 부분을 위한 주소값 생성이다.&lt;/li&gt;
  &lt;li&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string&lt;/code&gt;을 저장할 데이터 영역 주소를 따와서 프로퍼티 변수 주소에 반영해준다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj&lt;/code&gt; 주소에는 프로퍼티 변수들의 주소값이 할당된 주소를 반영해준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;복사에서도 기본형과 참조형은 차이를 보인다. 결론부터 이야기하면 기본형과 참조형 모두 ‘주소를 참조’한다. 다만, 기본형을 복사하여 값을 변경하면 ‘주소’가 새롭게 변경되는 것이고 참조형을 복사하여 내부 프로퍼티의 값을 변경하면 내부값을 담고 있는 주소는 변경되지 않지만 내부의 저장된 값의 주소들이 변경되는 것이다. 결국 참조형의 복사는 그릇의 주소가 변경되지 않기 때문에 기본적인 복사로는 불변성을 지킬 수 없다. &lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 동일한 데이터 영역 주소 참조&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;obj1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 동일한 객체 변수 영역 주소 참조&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 완전하게 새로운 데이터 영역 주소 참조&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;obj2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 객체 변수 영역의 주소는 동일하지만 c의 데이터 영역 주소만 변경된다.&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// a !== b&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// obj1 === obj2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/core-javascript/data-duplicate.png&quot; style=&quot;width: 80%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참조형 데이터가 ‘가변값’이라고 설명하기 위해서는 참조형 데이터 자체의 주소를 변경하는 경우가 아니라 그 내부의 프로퍼티 값들에 대한 주소를 변경할 때에만 성립한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/core-javascript.jpeg&quot; style=&quot;width: 80%; text-align: center; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="js" /><category term="series" /><category term="book" /><summary type="html">이 블로그 콘텐츠에는 책 ‘코어 자바스크립트’를 읽고 자바스크립트를 깊게 이해하는 내용이 담깁니다.</summary></entry><entry><title type="html">📚 프로덕트 오너(Product Owner)를 읽고</title><link href="https://hankyeolk.github.io/2021/04/08/book-productOwner.html" rel="alternate" type="text/html" title="📚 프로덕트 오너(Product Owner)를 읽고" /><published>2021-04-08T00:00:00+09:00</published><updated>2021-04-08T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/04/08/book-productOwner</id><content type="html" xml:base="https://hankyeolk.github.io/2021/04/08/book-productOwner.html">&lt;h2 id=&quot;intro&quot;&gt;Intro.&lt;/h2&gt;

&lt;p&gt;한 달에 적어도 8번 정도는 쿠팡의 로켓와우 서비스를 사용한다. 새벽배송을 넘어 출근하면서 주문한 딸기를 퇴근하면서 바로 먹을 수 있는 당일배송까지 책임진다. 배달의민족 앱을 터치한 것이 얼마나 먼 옛날인지 상상도 안 된다. 이제는 쿠팡이츠로만 배달 해먹는다. 필요한 물건이 있으면 쿠팡으로만 검색하고, 로켓배송이 안 되는 물건은 당장 필요없는 것이라고 의사결정한다. 쿠팡이라는 한 브랜드가 내 소피 패턴을 완벽하게 바꿔 놓았다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;나만 이렇게 생각하지는 않는 것 같다. 철저하게 쿠팡의 서비스만 고용하는 소비자가 주변에 심심치 않게 보인다. 어떻게 쿠팡은 나를 ‘쿠팡 의존자’로 만들 수 있었을까?에 대한 답이 이번에 읽은 책, &lt;strong&gt;프로덕트 오너(PO)&lt;/strong&gt;에 담겨있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;정답부터-말하자면&quot;&gt;정답부터 말하자면,&lt;/h2&gt;

&lt;p&gt;철저하게 프로덕트 중심으로 생각하고, 어떻게 하면 고객이 우리 서비스를 고용하게 만들지만 고민하는 사람이라고 프로덕트 오너를 짧게 정의 할 수 있겠다. 여기서 고객은 당연히 서비스 외부에서 앱 아이콘을 단순하게 터치하는 사람부터 그 범위에 포함된다. 서비스 내부에서 운영하고 에프터 서비스를 하고 심지어 물류를 관리하는 사람도 고객으로 볼 수 있다. 고객을 분류하고 각각의 부류에 어떤 가치를 전달해야 하는지를 정하는 것이 프로덕트 오너의 대표적인 업무다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;책의 저자분(쿠팡의 유명한 김성한 프로덕트 오너)는 고객이 어디에 있든, 현장에 있거나 공장에 있거나 전화상으로 의견을 전달하는 고객에게 마저 집착하는 것을 강조한다. 그리고 그런 집착을 주변 동료에게 전파하는 역할까지 프로덕트 오너의 주 업무라고 전한다. 개인 추천이 핵심인 넷플릭스, 쿠팡의 서비스가 이런 집착에서 빌드된 것이지 않을까 한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;단순하게 고객의 불편만 집착해서 개선하는 쪽으로 생각하는 것은 아니다. 고객이 느끼는 불편 사항이 어떻게 우리의 서비스의 고용으로 해결되는지 끊임없이 분석하는 것이 프로덕트 오너의 일이고, 그것이 프로덕트의 존재 이유라고 말한다. IT 기반의 서비스는 정말로 소비자가 ‘고용’하는 것이 맞다고 생각한다. 누군가가 오프라인에서 해줄 수 있는 일을 작은 기기에서 대신해주고 있기 때문이다. 그런 서비스를 만드는 것 자체에 담긴 고민이 ‘고용’을 이끌어내는 것으로 책에서는 표현된다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;고객에게-집착하기는-하지만&quot;&gt;고객에게 집착하기는 하지만,&lt;/h2&gt;

&lt;p&gt;회사가 정한 목표와 방향성을 절대 잃어버리면 안 되는 것이 프로덕트 오너가 주의할 점이다. 고객만 쫓아서 시선이 고정되면 프로덕트를 지탱하는 회사의 의지와 시선을 잃어버리기 쉽다. PO가 사업적 관점을 유지하고 경영진의 시각을 이해해야 더 치열하게 고객에게 집착하기 위한 일의 우선순위를 정하기 쉽다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;일의 우선순위는 당연하듯이 데이터를 기반으로 정해야 한다. 의사 결정은 말할 것도 없다. 매번 PO가 남기는 결정은 프로덕트와 회사 자체에 엄청난 영향을 준다. 그렇기 때문에 PO에게 직관은 멀리해야 하는 생각이다. 최대한 이성적으로 판단하고 데이터 기반으로 사고해야 한다. 직관마저 데이터를 기반해야한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;책을-읽어가면서-그리고-일고-나서&quot;&gt;책을 읽어가면서, 그리고 일고 나서.&lt;/h2&gt;

&lt;p&gt;회사에서 데이터를 접할일이 정말 많다. 직접 유저 데이터를 쌓는 경우도 있다. 어떤 데이터부터 찾아서 업무에 적용해봐야 할 지 모르겠다면 ‘목표’부터 수치화 하는 것을 연습을 하면 좋다. 나도 이 사실을 알게 된 것이 정말 얼마 안 된다. ‘프로덕트 오너’ 책을 읽고 있을때, 회사에서 매일 아침 일찍 오시는 다른 팀의 담당자님과 대화를 할 때 배웠다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;목표를 수치화 하는 것은 간단하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;어제의 지표를 20% 당장 30%로 올릴 수 있는 00 일을 진행해보겠다.&lt;/code&gt; 정도면 충분하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이 업무에서 00 일로 인해서 15번의 불만이 접수되었는데, 00 부분을 개선해서 8번으로 조정하겠다.&lt;/code&gt;도 괜찮다. 중요한 것은 내가 ‘수치’와 ‘데이터’를 기반으로 누군가에게 말할 수 있는 것 그 자체다. 그런데, 말은 이렇게 하지만 당장 데이터를 기반으로 말하고 사고하는 것은 힘들다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;그러면, 야구를 생각하면 된다. 내가 좋아하는 어떤 스포츠라도 상관 없다. 나는 야구를 좋아하는데, 한창 좋아할 때는 스타팅 라인업 9명 타자의 모든 타율을 다 외울 정도였다. 그러면 된다. 이 정도까지도 사실 필요없다. A라고 하는 선수가 데이터 통계적으로 보통 2할 8푼을 친다고 가정한다면 그 가정이 머리에 들어와서 누군가에게 전달할 정도만 데이터를 우선 접근하면 된다. 중요한 것은 ‘수치’와 그걸 기반하는 ‘데이터’다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;p&gt;이 책을 읽으면서 누군가에게 내가 지금 하고 있는 일을 설득시키는 과정에 대해 많이 배울 수 있었다. 6페이저(6-page)까지는 아니더라도, 내가 지금 어떤 프로젝트를 하고 있으며 어떤 비용을 투입해서 어떤 것을 기대하고 있는지가 자세히 기록된 기획서를 반드시 세우는 과정이 중요하다. 그 문서만으로 상대를 설득할 수 는 없지만 설득시킬 가능성은 높일 수 있다. 나 스스로가 그 일을 하는 것에 대한 목적성을 가지는 데에도 설득력이 높아진다. 지금 하고 있는 일이 나를 왜 고용해야 하는지 계속 질문하자.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;또한, 5단계의 질문까지는 아니더라도 최소 3번의 why는 외치고 일을 시작하게 되었다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지금 하고 있는 일이 무엇을 위해서 하는 일인가? 그러면 거기서 파생하는 또 다른 질문의 답은 무엇인가? 그러면 최종적으로 이 사소한 부분은 어떻게 생각하는가?&lt;/code&gt; 식으로 하나의 일에 꼬리를 무는 질문을 하면된다. 쉽지 않다. 주어진 일을 하는 것도 힘들 수 있다. 그렇지만 why를 가지지 않으면 일을 하는 것에 반드시 한계가 온다. 물론 책에서도 이런 스스로에 대한 질문의 단계를 강조한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h2 id=&quot;그래서-프로덕트-오너가-되고-싶은거야&quot;&gt;그래서, 프로덕트 오너가 되고 싶은거야?&lt;/h2&gt;

&lt;p&gt;프로덕트 오너에 대한 바람을 불어넣는 책은 절대 아니었다. 그렇다고 프로덕트 오너라는 직업이 있다 정도만 알려주는 책도 아니었다. 김성한님의 ‘프로덕트 오너’ 책은 스타트업이든 아니든 ‘프로덕트/서비스’ 기반의 회사를 다니는 모든 주니어가 가지면 좋을 생각의 방향성과 업무 처리 방식을 전달하는 것을 목적으로 가진 것 같다. 우리 시절의 수학의 정석이나 지금 나에게 자바스크립트 딥다이브 같은 책상에 두고두고 흔들릴 때마다 볼 수 있는 기본서 같다. 물론 읽고 실천하지 않으면 따라오는 미라클은 없을 것 같은 단호함도 있다. 지금 당장 업무에 써먹겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210408/productOwner.jpeg&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="book" /><summary type="html">Intro.</summary></entry><entry><title type="html">혹시라도 누군가가 새로운 맥(Mac)을 사준다면..</title><link href="https://hankyeolk.github.io/2021/03/20/onSettings.html" rel="alternate" type="text/html" title="혹시라도 누군가가 새로운 맥(Mac)을 사준다면.." /><published>2021-03-20T00:00:00+09:00</published><updated>2021-03-20T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/03/20/onSettings</id><content type="html" xml:base="https://hankyeolk.github.io/2021/03/20/onSettings.html">&lt;blockquote&gt;
  &lt;p&gt;저의 개발 환경은 다음과 같습니다. &lt;br /&gt;
사이드 및 공부 : MacBook-Pro-16 2019, Big Sur 11.1 &lt;br /&gt;
업무 : MacBook-Pro-13 2020, Catalina 10.15.7 &lt;br /&gt;
집에서 가지고 놀기 : Mac Mini M1, Big Sur 11.1 &lt;br /&gt;
이번 블로그는 인텔 기반의 맥을 대상으로 합니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;before-개발-공부&quot;&gt;Before 개발 공부&lt;/h3&gt;

&lt;p&gt;대학생 시절 사용했던 맥북프로에서 ‘터미널앱(terminal)’을 열어볼 일이 딱 한 번 있었다. 맥북을 나보다 일찍부터 사용했던 친누나와 함께 카페에서 공부를 할 때였다. 우연하게 누나 맥북을 봤는데, 런치패드에 앱 아이콘들이 작은 크기로 오밀조밀하게 잘 배치가 된 모습을 마주하고 내 것에도 해달라고 한 것이 그 시작이었다. 누나는 자연스럽게 터미널앱을 열더니 몇 가지 명령어(?)를 입력하고는 트랙패드에서 다섯 손가락을 오므렸다. 나의 맥북 런치패드도 동일하게 앱 아이콘들이 작은 크기로 오밀조밀 잘 모여있었다. 신선한 충격 뒤로는 터미널을 열기까지 아마 2년은 걸린 것 같다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210320/launchpad.png&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;위의 사진처럼 내가 새로운 맥을 사거나 또는 누군가에게 받으면 가장 먼저하는 일이 런치패드의 아이콘 사이즈를 줄이는 것이다. 디폴트로는 앱 아이콘들이 나에게는 너무 크다고 판단되어서 조금 귀찮지만 가장 먼저 해준다. 이렇게 만드는 방법은 아래의 명령어를 터미널앱에서 순서대로 입력하면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rows&lt;/code&gt;는 런치패드에 격자를 나눈다고 했을때 생성할 행의 갯수다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;columns&lt;/code&gt;는 반대로 열의 갯수를 의미한다. 사진에서 보면, 한 줄(행)에 7개의 앱 아이콘이 배치된 것을 알 수 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;defaults write com.apple.dock springboard-rows &lt;span class=&quot;nt&quot;&gt;-int&lt;/span&gt; 12
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;defaults write com.apple.dock springboard-columns &lt;span class=&quot;nt&quot;&gt;-int&lt;/span&gt; 7
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;killall dock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;github을 알기 시작하고 jekyll과 jQuery로 블로그를 만들 때 다시 터미널을 열어야 했다. homebrew(홈브루)&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;로 루비를 설치하고 git을 연결해주는 작업만 정말 하루 종일 검색하면서 진행했었다. 블로그를 구축한 다음에도 git 명령어를 통해서 포스팅하는 작업을 위해 터미널을 열었었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;이-블로그를-쓰는-목적&quot;&gt;이 블로그를 쓰는 목적&lt;/h3&gt;

&lt;p&gt;개발 공부를 시작하고 나서는 더 많은 것들을 맥에 세팅해주어야 했다. 이 설정들은 지금도 새로운 맥을 얻게 된다면 개발 환경 구축을 위해서 매번 해준다. 사실 이 블로그를 작성하는 가장 주요한 목적이 지금부터다. 매번 까먹기 때문에 더 이상의 검색을 하지 않고 바로 블로그로 확인하기 위해서!&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;1-iterm2-설치와-homebrew-oh-my-zsh-설정&quot;&gt;1. Iterm2 설치와 Homebrew, oh-my-zsh 설정&lt;/h3&gt;

&lt;p&gt;그렇다. 맥에서 기본적으로 제공하는 터미널앱은 이제 이쁘지가 않다. 나는 &lt;a href=&quot;https://iterm2.com/&quot;&gt;Iterm2&lt;/a&gt;를 사용한다. macOS 10.14 버전 이상부터 지원하는 터미널앱이고 다양한 테마를 사용할 수 있다! (쑤아리-📣) 그리고 다양한 개발 프로그램을 설치할 수 있게 도와주는 Homebrew를 설치한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;Homebrew 설치 전에 Iterm2를 실행시키면 똑똑한 맥이 auto-install을 통해서 개발환경을 구축하냐고 묻는다. 그때 확인 버튼을 누르면 xcode와 관련된 설치가 진행된다. (xcode 자체를 설치하는 것은 아니다!) 그런데, 중고로 맥을 사면 이 auto-install 팝업이 뜨지 않는 것도 같았다. 그럴때는, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ xcode-select --install&lt;/code&gt;로 개발 환경을 구축할 수 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;는 공식문서 가장 상단에 설치 코드가 있다. 그 코드를 복사해서 터미널에 붙여넣으면 끝난다. M1칩이 들어간 맥미니에서 Homebrew를 설치할 때 애를 먹긴했다. 로제타로 우회해서 설치하고 나중에 nvm 설정을 잡아줄 때도.. 우선 M1에 대한 내용은 다음에 정리하기로 하자.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;Homebrew 설치가 완료되면 이제 Iterm에 새로운 옷을 입혀줘야 한다. Homebrew를 굳이 먼저 설치할 필요는 없지만, wget을 사용할 것이라면 있는 것이 좋다. wget은 url을 기반으로 파일을 다운받는 프로그램이다. wget을 이용해서 Iterm에 &lt;a href=&quot;https://ohmyz.sh/#install&quot;&gt;OH-MY-ZSH&lt;/a&gt;를 한다. 역시 공식문서에 설치 관련 설명이 잘 되어있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;wget
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; -&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;2-oh-my-zsh에-이쁜-테마-입히기&quot;&gt;2. oh-my-zsh에 이쁜 테마 입히기&lt;/h3&gt;

&lt;p&gt;oh-my-zsh는 정말 다양한 테마를 제공한다. 그 중에서 나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;agnoster&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fletcherm&lt;/code&gt;을 사용하는데 정말 다양한 &lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&quot;&gt;테마&lt;/a&gt;가 있기 때문에 맘에 드는 것을 찾아서 사용하면 된다. 테마 변경은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt; 파일에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZSH_THEME=&quot;여기에 원하는 테마를 입력하세요&quot;&lt;/code&gt;에 반영하면 된다. 구글에 검색하면 정말 많은 oh-my-zsh 테마를 다루는 방법을 찾을 수 있다. 😀&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano ~/.zshrc
&lt;span class=&quot;nv&quot;&gt;$ ZSH_THEME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fletcherm&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 반영한 다음에는 ctrl + x -&amp;gt; ctrl + y -&amp;gt; enter 로 저장하고 나온다!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;3-vscode-설치하고-path-설정에서-code-명령어-먹이기&quot;&gt;3. VSCode 설치하고 Path 설정에서 code 명령어 먹이기&lt;/h3&gt;

&lt;p&gt;역시 그렇다. VSCode를 주력 에디터로 사용하면 모든 문서, 코드 작업을 거기서 하게된다. &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode&lt;/a&gt;를 설치하고 열어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmd shift P&lt;/code&gt;를 누르면 어떤 검색창 같은 것이 에디터 상단에 나온다. 그 검색창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt;를 입력하면 터미널창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code .&lt;/code&gt; 명령어로 VSCode를 열수 있게 등록하는 액션이 나오는 것을 경험할 수 있다. (아래 사진 참고!)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210320/vscode.png&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;4-git-alias-등록하고-git-editor-기본-설정하기&quot;&gt;4. Git Alias 등록하고 git, editor 기본 설정하기&lt;/h3&gt;

&lt;p&gt;Iterm으로 주로 git 명령어를 많이 활용한다. 그 과정에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit -m&lt;/code&gt; 등과 같은 길고 번거로운 명령어를 매번 입력하기 귀찮아서 oh-my-zsh에 등록해서 사용중이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code . ~/.zshrc&lt;/code&gt;를 입력해서 VSCode에서 쉽게 zsh 설정을 변경해주자.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# .zshrc 파일&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;gl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;git log --graph --decorate --oneline --all&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;gs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;git status&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clear&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mysql -u root -p&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;주로 위의 단축형 alias를 설정한다. 더 많지만 다 적기에는 너무 커스텀화 되어 있어서 소개하기 애매했다. 파일에 등록한 alias는 Iterm2에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt; 명령어를 입력해서 적용해 줄 수 있다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;그 다음에 내 컴퓨터에서 버전 관리를 목적으로 사용하는 git과 터미널에서 사용할 에디터의 기본값을 설정해준다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.name &lt;span class=&quot;s2&quot;&gt;&quot;hankyeolk&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt; user.email &lt;span class=&quot;s2&quot;&gt;&quot;email@email.com&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--glboal&lt;/span&gt; core.editor &lt;span class=&quot;s2&quot;&gt;&quot;nano&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;5-nvm으로-nodejs를-설치해주면-끗&quot;&gt;5. NVM으로 Node.js를 설치해주면 끗!&lt;/h3&gt;

&lt;p&gt;나는 Node.js를 활용해서 웹 개발을 하는 개발자다. 그렇기 때문에 Node의 버전을 쉽게 관리하도록 도와주는 NVM의 설치는 필수적이다. NVM 역시 wget으로 손쉽게 설치할 수 있다. 아래의 코드로 설치가 잘 된다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvm --version&lt;/code&gt; 명령어를 입력했을 때 하단에 버전이 잘 뜰 것이다!&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget &lt;span class=&quot;nt&quot;&gt;-qO-&lt;/span&gt; https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;그런데 종종 nvm을 설치하다 보면 설치 도중에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvm is already installed&lt;/code&gt;라고 하는 벼락과 같은 문구가 뜰 수 있다. 그럴때는 당황하지 말고 아래의 방법을 시도해보자! nvm에 대한 설정이 export 되지 않아서 발생하는 경우가 거의 대부분이다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano ~/.zshrc

&lt;span class=&quot;c&quot;&gt;# nano&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;NVM_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;XDG_CONFIG_HOME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; %s &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;HOME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/.nvm&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; %s &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;XDG_CONFIG_HOME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/nvm&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NVM_DIR&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/nvm.sh&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NVM_DIR&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/nvm.sh&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# ctrl + x -&amp;gt; ctrl + y -&amp;gt; enter&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 18px&quot;&gt; &lt;/p&gt;

&lt;p&gt;NVM이 잘 설치됐다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvm install 14.16.0&lt;/code&gt; 등의 방식으로 Node.js를 설치하고 사용하면 된다. 나는 보통 LTS 버전을 우선적으로 설치하고 그 다음에 Current 버전을 설치해서 사용한다. 개발은 Current 버전을 이용한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;p&gt;새로운 맥을 어떻게든 얻게된다면 더 이상 찾아보는 수고를 하지 않고 이 블로그를 참고해야겠다. 새로운 맥이 언제 생길지 모르겠지만 그렇게 하자! 😆&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;hr /&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;mac os에서 사용하는 패키지 매니저. GUI의 도움 없이 프로그램을 설치하고 제거할 수 있게 도와주는 역할을 한다. 웹상에서 존재하는 운영체제에 맞게 제작된 프로그램을 내 컴퓨터에 쉽게 설치하기 위해 도와준다. 맥에서는 homebrew가 그 패키지 매니저 역할을 한다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>hankyeolk</name></author><category term="etc" /><summary type="html">저의 개발 환경은 다음과 같습니다. 사이드 및 공부 : MacBook-Pro-16 2019, Big Sur 11.1 업무 : MacBook-Pro-13 2020, Catalina 10.15.7 집에서 가지고 놀기 : Mac Mini M1, Big Sur 11.1 이번 블로그는 인텔 기반의 맥을 대상으로 합니다!</summary></entry><entry><title type="html">원정대를 성공적(?)으로 마무리하면서.</title><link href="https://hankyeolk.github.io/2021/02/27/databaseExpedition.html" rel="alternate" type="text/html" title="원정대를 성공적(?)으로 마무리하면서." /><published>2021-02-27T00:00:00+09:00</published><updated>2021-02-27T00:00:00+09:00</updated><id>https://hankyeolk.github.io/2021/02/27/databaseExpedition</id><content type="html" xml:base="https://hankyeolk.github.io/2021/02/27/databaseExpedition.html">&lt;blockquote&gt;
  &lt;p&gt;주의. 이번 블로그는 반지의 제왕 덕후적인 용어들이 제법 나옵니다. 그냥 덕후구나 하고 넘어가주세요. 🧙‍♀️&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;내가 지금 다니고 있는 회사에는 ‘원정대’라는 업무 조직이 있다. “원정대?”라고 생각이 들 수 있다. 그런데 그 생각과 더불어 영화 ‘반지의 제왕’의 그 &lt;strong&gt;&lt;em&gt;반지 원정대&lt;/em&gt;&lt;/strong&gt;가 생각난다면 정확하게 맞다. 선택받은 호빗 ‘프로도’와 간달프, 아라곤 등등이 팀을 꾸려서 모르도르의 산으로 절대반지를 옮기는 그 반지 원정대처럼 선택 받은 (개인의 선호도가 정말 많이 반영된) 구성원들이 자유롭게 TF팀을 구성하는 것을 &lt;strong&gt;‘원정대’&lt;/strong&gt;라고 부른다. 어제까지해서 나도 하나의 절대 반지를 성공적으로 모르도르로 옮길 수 있었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;원정대가-리벤델에서-킥오프로-시작하다&quot;&gt;원정대가 리벤델에서 킥오프로 시작하다.&lt;/h3&gt;

&lt;p&gt;원정대가 발대하면서 킥오프 미팅을 진행했다. 원정대원들과 기존 컨텐츠에 대한 피드백을 주고받는 것으로 시작되었다. 컨텐츠 제작자의 피드백과 실제 소모자들의 피드백에는 차이가 있는 경우가 대부분이기 때문이다. 정말 살벌하게 피드백했다. 우리가 새롭게 디자인할 컨텐츠는 어떤 피드백을 받을 수 있을지 궁금해하면서 쳐낼 것은 쳐내고 남길 것은 무엇인지 깊게 논의했다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;피드백에는 항상 공통점이 있다. 그 공통점이 좋은 쪽으로 “맞아 맞아” 하면서 더 좋은 쪽으로 개발되도록 공유되기도 하지만, 보통은 “맞아, 그거 불편해요”가 더 많다. 킥오프에서 나왔던 공통점들도 그랬다. 그래서 기존 컨텐츠를 전체적으로 들어내고, 다른 컨텐츠에 새로운 FILL ME IN을 넣는 방향성을 정했다. 원정대가 모르도르에 도착해야 하는 시기(due-date)가 그렇게 길지 않았기 때문에 스프린트에서 집중적으로 고민해봐야 할 내용을 중점으로 개선 포인트를 잡았다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;헬름-협곡에서-계속해서-삽질을-반복했다&quot;&gt;헬름 협곡에서 계속해서 삽질을 반복했다.&lt;/h3&gt;

&lt;p&gt;원정대 일정 중간에 설 연휴가 있었다. 그래서 연휴 전까지 기존 컨텐츠의 부채를 해결하기로 했다. 플랫폼에서 컨텐츠 자체를 수정하면서 연휴를 기다렸는데, 연휴 이후에 남은 일정이 그렇게 많아 보이지 않았다. 프로도와 샘이 골룸을 만난 느낌이었다. 이 시기에 내가 새로운 컨텐츠도 만들고 피드백도 받고 개선하고 배포하는 전체적인 과정을 다 할 수 있을까 하는 의심이 생겼다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;

&lt;p&gt;원정대 대원에게 긴급하게 콜을 했고, 업무를 빠르게 분담했다. 코스 동기이자 입사 동기인 크루가 함께하는 원정대원이라 편하게 정할 수 있었다. 나는 영어로 적혀있는 컨텐츠를 교육 자료로 사용될 수 있게 번역하는 업무를 배정받았다. 외국 개발자들이 적어둔 양질의 컨텐츠를 번역해서 공부하는 개발자가 많아서 나도 한 번 해보고 싶었다. 그리고 현실로도 너무 공부가 많이 됐다. 한 문장을 번역하면 이해해야 할 것이 쏟아졌기 때문이다. 컨텐츠 번역을 시작하면서 우리 원정대는 헬름 협곡에 들어갔다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;설 연휴에 부산 본가를 내려가지 않기로 결정을 내리면서 오랜만에 Express로 서버 코드를 작성했다. 원정대의 서버가 Express.js를 기반으로 MySQL 데이터베이스 서버를 연결해야 했기 때문이다. 라우팅을 나누고 MVC 패턴을 기반으로 Model의 Query 요청 메서드, Controller의 요청, 응답 메서드를 구분했다. HTTP 응답 코드가 애매해서 일단 409로 에러를 날렸는데, 이후에 원정 대장님이 잘 찾아보고 알맞는 에러를 알려주는게 좋다고 바로잡아 주셨다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원정 대장님은 정말로 간달프다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;설이 지나고 본격적으로 코드를 논의했다. 내가 원정대 업무 말고도 다른 운영 업무에 관계된 부분이 많아서 정말 정신이 없었다. 그래도 다행스러웠던건 설이 지나자 기적처럼 정부가 거리두기를 2단계로 조정했다는 사실이다. 그래서 회사가 다시 오프라인 근무로 전환되었고 코드를 바로 바로 보면서 진행할 수 있었다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;원정대에도 나즈굴과 같은 존재가 있었다. 나였다. 내가 나즈굴이었다. 원정대에 집중을 많이 못해서 내 동기가 혼자서 오크와 같은 에러들을 해결해야 했다. 헬름 협곡은 내 자리였고 사방에서 오크들이 밀려왔다. 실시간으로 코드를 비교하고 피드백하기 위해서 동기가 기존 자리를 벗어나 내 옆자리로 옮기는 모습이 헬름 협곡의 새벽을 연상캐했다. 원정대가 끝나가는 시점에 동기의 자리가 완전히 내 옆자리로 픽스된 걸 보면 우리가 정말 치열하게 협업한 건 맞나보다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;중간 중간 여러명의 간달프가 오고가서 컨텐츠 코드가 탄탄해지는 경험을 했다. 로우 쿼리를 오랜만에 작성해서 w3school로 공부했던 그 시절을 다시 떠올려보기도 했다. 여러번 입고 있던 미스릴 갑옷의 덕을 보기도 했다. (도대체 무슨 비유를 하고 싶은 건지 글을 적으면서도 잘 모르겠다. 촤하하)&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;이제-남은-것은-절대-반지-앞에서-이성을-잃지-않는-것&quot;&gt;이제 남은 것은 절대 반지 앞에서 이성을 잃지 않는 것.&lt;/h3&gt;

&lt;p&gt;원정대의 최종 기한이 다가오면서 내가 배정받은 세션이 부담되기 시작했다. 처음해보는 라이브 학습 세션이라 너무 긴장할 수 밖에 없었다. 문제를 작성하고 설명에 필요한 자료를 하나씩 준비했다. 이미지, 슬라이드, 스크립트를 차례로 준비하면서 1주일 내내 야근을 진행했다. 원정대원인 동기도 매일 늦게 퇴근하면서 나의 리허설, 세션, 그리고 본인의 세션을 열심히 준비했다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;대망의 세션날, 회사는 전사 리모트를 진행했다. 사무실에 출근하는 사람이 5명 정도였고 나도 그 중 하나였다. 3시 반 세션을 위해서 정말 쉬지 않고 스크립트를 읽었다. 실제로 진행하는 것처럼 시뮬레이션 하면서 진행했다. 그리고 모르도르의 용암에 절대 반지를 잘 던지고 나왔다. 막힘이 없지는 않았다. 하지만 분위기에 익숙해지니까 쉴 수가 없었다. 방음부스의 공기가 용암 근처의 뜨거운 열기처럼 달아올랐다. (소설을 쓰고 있네…)&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 48px&quot;&gt; &lt;/p&gt;

&lt;h3 id=&quot;원정대가-나에게-남긴-것&quot;&gt;원정대가 나에게 남긴 것&lt;/h3&gt;

&lt;p&gt;이번에 진행한 원정대 업무는 부담이 컸지만 즐거웠다. 그전까지 동기분과 말을 많이 해보지 못했는데, 원정대때 정말 말을 많이하고 수많은 피드백을 주고 받아서 개인적으로는 되게 많이 친해진 것 같다. 그리고 하나의 컨텐츠를 만드는 것에 직접 참여한 경험을 얻었다. 내가 만든 컨텐츠가 많은 수강생에게 소비되어 지식으로 남는 과정에 희열을 느꼈다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 15px&quot;&gt; &lt;/p&gt;

&lt;p&gt;다음에 또 다른 원정대를 하라고 하면 선뜻 “와 제가 무조건 하겠습니다”는 못 할 수 있겠지만 (이게 본심인가.. 🧙‍♀️) “하고 싶지 않습니다.”는 절대 나오지 않을 것 같다. 운영 업무쪽에서도 원정대를 꾸려야 할 부분이 많을 것 같아서 먼저 제안해보고 싶은 마음도 크다. 아라곤이나 간달프 같이 주요한 역할은 못 하더라도 김리, 피핀 정도는 할 수 있지 않을까 한다.&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 25px&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/posts/210227/expedition.png&quot; style=&quot;width: 100%; border: 1px solid gray;&quot; /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p style=&quot;display: block; margin-top: 0px; margin-bottom: 32px&quot;&gt; &lt;/p&gt;</content><author><name>hankyeolk</name></author><category term="work" /><category term="review" /><category term="database" /><category term="backend" /><summary type="html">주의. 이번 블로그는 반지의 제왕 덕후적인 용어들이 제법 나옵니다. 그냥 덕후구나 하고 넘어가주세요. 🧙‍♀️</summary></entry></feed>