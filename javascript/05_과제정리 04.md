---
layout: post
title: "PRE-Underbar 과제 정리 - 02"
subtitle: "lodash, underscore.js 와 같은 라이브러리의 함수들을 구현해보자."
type: "Javascript"
createDate: "2020-07-09"
js: true
text: true
author: "hankyeolk"
post-header: false
header-img: ""
order: 5
---

#### advanced 01. _.flatten 함수 작성하기

- 처음에는 flat(Infinity) 메소드를 이용해서 해결해봤다. 테스트는 통과했지만 깨림칙했다.
- 재귀를 공부하고, 재귀로 해당 문제를 해결 할 수 있을 것 같았다. 
- 원본 배열에서 요소로 배열이 있으면 재귀를 돌린다. > 오우!
<br>

```js
// 완성될 배열을 넣을 result 인자를 고정시켰다. 
// 이렇게 해주면 재귀가 아닐때, 빈 배열에 push 되고
// 재귀를 돌 때, 값이 들어있거나 아닌 result 배열에 값을 넣어 계속 발전 시킬 수 있다.
_.flatten = function(array, result = []) {
   // 순환하여 도는 array 이기에 for ~ of 구문을 사용했다. 
   for (let el of array) {
      if (!Array.isArray(el)) {
         // array의 첫 요소부터 반복하여 돈다.
         // 해당 요소가 배열이 아니라면 그냥 result에 넣는다.
         result.push(el)
      } else {
         // 만약 el이 배열이라면, 재귀!
         // 여기서 result는 값이 들어있거나 아닌 요소 그 자체다.
         _.flatten(el, result)
      }
   }

   return result;
}
```

기본값을 가지는 인자를 변형해가면서 재귀 함수를 돌리는 요소가 계속해서 보인다. 해당 부분을 연습할 필요가 있다. 

<br>

#### advanced 02 _.shuffle 함수, 기존 배열을 랜덤하게 정렬하는 새로운 배열 나타내기

- 배열의 길이 만큼 랜덤한 인덱스가 나올 수 있도록 한다.
- Math.random(), Math.floor() 메소드를 잘 활용한다.
- immutable한 구조의 함수를 만들어야 한다. > 함수의 인자로 들어오는 배열은 immutable 해야 한다는 뜻
<br>

```js
_.shuffle = function(array) {
   // 결과를 담을 배열을 만든다.
   let resultArray = [];

   // array의 요소들을 랜덤하게 뽑아서 resultArray에 하나씩 push 할 예정이다.
   // 이 말은 최종적으로 array와 resultArray의 길이가 같아야 한다는 뜻
   while (resultArray.length !== array.length) {
      // 반복문 안에서 배열의 인덱스 만큼 랜덤한 숫자를 뽑아야 한다.
      let randomIdx = Math.floor(Math.random() * array.length)

      // resultArray에 기존 array의 랜덤한 인덱스의 요소가 없다면,
      // 우리는 해당 요소를 resultArray로 넣을 수 있다.
      if (resultArray.includes(array[randomIdx]) === false) {
         resultArray.push(array[randomIdx]);
         // 조건문이 끝나면 다시 두 배열의 길이를 비교하고,
         // 반복문 안에서 새로운 인덱스가 생성된다. 
      }
   }
   return resultArray
}
```
<br>
이 문제에서 사용한 랜덤한 인덱스를 뽑는 `randomIdx`의 식을 위와 같이 구성한 것은 이렇다.

- `Math.random()` 은 0과 1 사이의 랜덤한 실수를 뱉는다.
- Math.random() 으로 나온 실수에 배열의 길이를 곱하면 0보다는 크고 배열의 길이보다는 작은 수가 나오게 된다.
- 위에서 계산된 수를 `Math.floor()` 를 이용하여 임의적으로 *내림* 해준다.
- 그렇게 되면 최종적으로 나타나는 값은 0, 1, ... 배열의 길이 - 1 의 범위를 가지는 정수가 나온다.

